---
layout: post
title: MTE 관련 문서 번역
category: [intern]
tags: [mte, arm, memory safety]
fullview: true
comments: true
use_math: true
author: fault2000
---

**[pdf 링크](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwi8kPSa4Kv2AhWgUfUHHQTCA1MQFnoECCcQAQ&url=https%3A%2F%2Fdeveloper.arm.com%2F-%2Fmedia%2FArm%2520Developer%2520Community%2FPDF%2FArm_Memory_Tagging_Extension_Whitepaper.pdf&usg=AOvVaw12l-TyFWLy8JrjhIa_uwHl)**

## Introduction

메모리 안전 위반은 크게 두 종류로 나뉜다. 공간적, 시간적 안전이다.  
공간적 안전은 객체가 진짜 범위를 넘어서 접근 할 경우 발생한다.  
시간적 안전은 일반적으로 객체가 재할당된 후 개체에 대한 참조가 범위를 벗어나면 침해된다.  
MTE는 위 두 위반을 감지하는 메커니즘을 제공한다. MTE는 테스팅 및 [퍼징](#fuzzing)의 효율성을 높여 프로그램 배치 전 가능한 취약점을 감지하는 것을 지원한다. 또한 배포 후 규모에 맞는 취약점 탐지를 지원한다.

## Threat Model

MTE는 공격자가 제공하는 악의적인 코드를 실행시키는 시도를 하는 공격에 대한 견고성을 제공하도록 설계되었다. 알고리즘 취약성 혹은 악성 소프트웨어는 다루지 않는다.  
MTE는 메모리 안전 위반을 감지하도록 설계되었으며, 위반을 가능하게 하는 공격에 대한 견고성을 증가시킨다. 동적 링킹 시스템에서, 레거시 코드는 재컴파일 없이 힙 할당을 위해 MTE의 이점을 이용한다.  
MTE를 스택에 적용하는 것은 재컴파일을 필요로 한다. MTE 구조는 스택 포인터가 믿을만하다는 가정으로 설계되었다. 따라서 스택 할당을 위해 MTE를 배포할 때 공격자가 스택 포인터를 제어할 수 있는 가젯이 존재할 가능성을 줄이기 위해 MTE를 BTI(Branch Target Identification)과 PAC(Pointer Authentication Code)와 같은 다른 기능과 결합하는 것이 중요하다.

## Memory Safety with MTE

Arm MTE(Memory Tagging Extension)은 메모리에 대한 잠금 및 키 액세스를 구현한다.  
메모리 접근 중에 제공되는 메모리에 잠금을 설정할 수 있고, 키가 메모리 접근 중 제공된다. 만약 키가 자물쇠와 맞다면, 접근이 허가되고, 아니라면 에러가 보고된다.  
메모리 위치는 각 16 바이트의 물리적 메모리에 4 bits의 메타데이터를 추가하여 태그된다. 이것을 태그 그랜룰(Tag Granule)이라고 하며 메모리에 태그를 지정하면 잠금이 구현된다.  
포인터, 즉 가상 주소는 키를 포함하도록 수정된다.  
더 큰 포인터를 요구하지 않고 키 비트를 구현하기 위해, MTE는 Armv8-A 아키텍처의 TBI(Top Byte Ignore)기능을 사용한다. TBI가 활성화된 경우, 가상 주소를 주소 변환을 위한 입력으로 사용할 때 가상 주소의 상위 바이트가 무시되며 이는 상위 바이트가 메타 데이터를 저장할 수 있게 한다. MTE에서는 4bits를 키를 제공하는데 사용한다.  

MTE는 자물쇠와 열쇠에 서로 다름을 통해 메모리 안전 위반을 감지한다. 가능한 비트는 제한되있기에, 두 메모리 할당이 아무 특정 실행에서 서로 다른 태그를 가지게 될 것을 보장하지 못합니다. 하지만, 메모리 할당기가 순차적 할당의 태그가 항상 다를 것을 보장할 수 있으므로 따라서 안전 위반의 가장 흔한 타입은 감지됨을 보장한다.  

더 일반적으로, MTE는 무작위 태그 생성과 시드를 기반으로 한 수도-랜덤 태그 생성을 지원한다. 충분한 양의 프로그램 실행과 함께라면, 위반을 최소 하나라도 감지할 확률은 100%에 육박한다.

## Architectural Details

MTE는 Normal Tagged Memory라는 새로운 메모리 타입을 arm 아키텍처에 추가한다. 접근의 안전을 정적으로 결정할 수 있는 몇몇 예외를 제외하고, 이 새로운 메모리 타입에 대한 load, store는 주소 레지스터의 상위 바이트에 있는 태그를 메모리에 저장된 태그와 비교하는 접근을 수행한다.

주소 속의 태그와 메모리 속의 태그 간의 불일치는 동기화 예외를 일으키거나 비동기 보고를 하도록 설정할 수 있다. 불일치가 비동기 보고를 하도록 설정할 때, 시스템 레지스터 속에 상세 정보가 누적된다. 더 높은 예외 수준에서 실행되는 소프트웨어에 대한 입력 시, 이 레지스터가 업데이트되도록 하는 제어 기능이 제공된다. 이를 통해 운영 체제 커널은 특정 실행 쓰레드에서 불일치를 분리하고 이 정보를 기반으로 결정을 내릴 수 있다.  

동기화 예외는 태그 불일치의 원인이 되는 load 혹은 store 명령을 정확하게 결정할 수 있다는 점에서 정확하다. 반대로, 비동기 보고는 특정 실행 스레드에 대한 불일치를 분리하는 것만이 가능하기에 부정확하다.  

MTE는 Armv8-A 아키텍처에 명령을 추가했으며 이들은 아래에서 세 가지 다른 카테고리로 그룹화되어 정리되었다.

## 스택과 힙 태깅에 사용할 수 있는 태그 조작을 위한 명령

### IRG

MTE의 통계적 기반이 유효하기 위해선, 랜덤 태그의 소스가 필요하다. IRG는 하드웨어에 이를 제공하고 다른 명령들이 사용할 수 있도록 레지스터에 이러한 태그를 삽입하도록 정의된다.

### GMI

이 명령은 IRG 명령과 함께 사용하기 위해 제외된 태그 집합을 조작하기 위한 것이다. 이것은 소프트웨어가 일반적인 할당을 위해 랜덤 태그 동작을 유지하면서 특별한 목적을 위해 특정 태그 값을 사용하는 경우를 위해 고안되었다.

### LDG, STG, and STZG

이 명령들은 메모리 속에 태그를 가져오거나 설정할 수 있다. 이들은 데이터를 수정하거나 0으로 초기화하지 않고 메모리 속 태그를 변경하기 위한 것이다.

### ST2G and STZ2G

이들은 할당 크기가 두 개의 최소 메모리 블럭(granule of memory)일 때 동작하는 STG와 STZG 보다 밀도 높은 대안이다.

### STGP

이 명령은 메모리에 태그와 데이터를 같이 저장한다.

## 포인터 연산과 스택 태깅을 위한 명령

### ADDG and SUBG

이들은 주소에 대해 연산을 하는 더하기와 빼기 명령의 변종이다. 이들은 각 태그와 주소를 상수(immediate value)로 수정할 수 있게끔 허락한다. 이 명령들은 스택에서 개체의 주소를 만드는 일을 위해 고안되었다.

### SUBP(S)

이 명령은 상위 바이트의 태그를 무시하는 포인터 연산을 위해 필요한 선택적 flag 설정을 지원하는 56-bit 뺄셈을 제공한다.

## 시스템이 사용하도록 설계된 명령:

### LDGM, STGM, and STZGM

이들은 EL0에서 정의되지 않은 대량 태그 조작 명령들이다. 이는 시스템 소프트웨어가 초기화 및 직렬화를 목적으로, 태그를 조작하기 위한 것들이다. 예를 들어, 태그된 메모리를 태그를 인식하지 못하는 매체로 스왑할 때 사용될 수 있다. 0으로 만드는 형식은 메모리의 효율적인 초기화를 위해 사용될 수 있다.  
게다가, MTE는 태그와 함께 사용하도록 설계된 캐시 유지 명령 집합을 제공한다. 이들은 전체 캐시 라인에서 작동하는 효율적인 메커니즘을 제공한다.

## Deploying MTE at Scale

Arm은 MTE가 제품 개발 및 배포의 다양한 단계에서 서로 다른 구성으로 배포될 것으로 예상했다.  
정확한 확인은 실패의 위치에 대한 가장 정확한 정보를 제공하기 위한 것이고 부정확한 검사는 더 높은 성능을 위한 것들이다.  
OS 커널은 태그 불일치로 인한 예외를 일으키는 프로세스를 종료(terminate)하거나 불일치를 기록하고 프로세스가 계속 진행되도록 둘 중 하나를 선택할 수 있다.
출시 전 MTE로 제품을 검사하는 것은 많은 제품의 잠재해있는 문제를 발견할 수 있을 것이다. 이 단계에서는 가능한 한 많은 문제에 대한 정보를 감지하고 기록하는 것이 적절하다. 이 시스템은 공격자로부터 보호하는 것이 불필요하다. 시스템을 다음과 같이 구성하는 것이 적절할 것이다.

- 정확한 검사를 수행
- 프로세스 제거 대신 태그 불일치에 대한 정보를 축적할 때

이 설정을 사용하면 직접적인 테스팅과 퓨징을 통해 최대 결점 수를 찾을 수 있도록 도와주어 대부분의 정보를 수집할 수 있다.  

제품 출시 후, MTE를 다음과 같이 설정하는 것이 적절할 것이다.

- 부정확한 검사 수행
- 태그 불일치 시 프로세스 종료

이 설정은 성능과 소프트웨어에 대한 공격을 할 수 있는 메모리 안전 위반 탐지 간의 균형을 제공한다.  
출시 후, 버그 보고 및 원격 측정 시스템을 통해 검사 실패 위치에 대한 정확한 정보를 개발자에게 전달할 수 있도록 암호 키 저장소와 같은 해커에게 가치가 높은 프로세스를 정확한 검사를 수행하도록 설정하는 것이 적절할 것이다.  
시스템이 적응하여 MTE 설정을 변경하는 것도 아마 적절할 수 있을 것이다. 예를 들어, 만약 부정확한 검사를 실행 중이던 프로세스가 태그 검사 실패로 종료되었다면, 다음에는 개발자들에게 더 나은 진단 정보를 수집해주기 위해 정확한 검사와 같이 시작하도록 프로세스를 실행하는 것이다. 이 개발 모델은 부정확한 검사의 성능적 이득과 정확한 검사의 더 나은 피드백의 질적 이득을 섞은 것이다.

## Deploying MTE in Hardware

![image](https://user-images.githubusercontent.com/73513005/157191519-11ed0466-1cec-401d-9e41-d177b6de06d1.png)

## Deploying MTE in Software

MTE는 여러 배치 단계를 지원하도록 설계되었다.

### Heap Tagging

동적 링킹 시스템에서, 현존하는 바이너리를 바꾸지 않고도 태그된 힙을 배치하는 것이 가능하다. 오직 OS 커널과 C 라이브러리 코드가 대신 필요할 뿐이다.  
Arm은 리숙스 커널에 대한 지원을 추가함으로써 MTE의 프로토타입을 만들었다. 다음과 같은 부분이 수정되어야 한다.

- 주소 공간 관리를 위해 사용될 때 유저 공간 포인터의 태그를 지우는 능력
- 가상 메모리 시스템 속 clear_page, copy_page 함수가 태그를 알아보도록 만듬
- 불일치한 태그로 인한 실패를 다루기 위한 지원 추가, 이는 변환 결함이 SIGSEGV로 처리되는 방식과 유사함
- 일반 태그 메모리를 사용하기 위해 사용자 공간 프로세스에 노출될 수 있는 메모리 매핑 변환
- 확장과 확장을 사용하기 위한 시스템 레지스터 설정에 대한 감지 추가

Arm은 리눅스 커널 지원 업스트림에 기여하는 과정에 있다.  
C 라이브러리에서, Arm은 다음과 같은 메모리 관련 함수를 조작한다.  

- malloc
- free
- calloc
- realloc

게다가, 메모리 복사와 문자열 관련 함수는 소스 버퍼를 덮어쓰는 것을 방지하기 위해 수정되었다.

### Stack Tagging

런타임 스택에 태그된 메모리를 할당하는 것은 컴파일러 및 커널 지원을 필요로 한다. 바이너리는 반드시 재컴파일되어야 한다. 스택 태깅을 위한 많은 다른 전략이 가능하다.  
우리의 파트너들은 새 스택 프레임이 할당될 때 함수 진입 동안 IRG 명령을 사용해 랜덤 태그를 선택하기 위한 전략을 프로토타입으로 제작했다. 컴파일러는 ADDG와 SUBG 명령어를 사용하여 함수 내의 각 스택 슬롯에 대한 태그된 주소를 생성하며, 여기서 태그는 초기 랜덤 태그에서 오프셋된다. 스택 할당은 적절한 태그 저장 명령을 사용해 대량 초기화될 수 있지만 컴파일러는 함수의 몸통 코드에 의해 사용되기 전에 초기화될 수 있는 슬롯은 초기화할 필요가 없다.  
이 전략은 MTE의 통계적 속성이 각 함수 호출에 유효함을 보장하며, 스택의 인접한 객체가 서로 다른 태그를 가지도록 보장하므로 따라서 순차적 오버플로우와 언더플로우가 발각된다.  
스택의 인접한 객체를 보호하려면 해당 객체를 태그 그래뉼(즉, 16 바이트)에 정렬해야 한다. 몇몇 프로그램에서, MTE는 이 효과 때문에 스택 사용량 증가를 발생시킨다. 우리의 벤치마킹은 이 증가가 보통은 작음을 보여준다.  
성능을 증가시키기 위해, 스택 포인터 주소 지정 모드에서 immediate-offset을 사용하는 메모리 액세스는 MTE에서 선택 해제된다. 왜냐하면 이것은 컴파일러가 정적으로 그들이 옳음을 증명하거나 컴파일 시간에 진단을 내릴 수 있기 때문이다.

## Optimizing for MTE

MTE는 코드를 검사하기 위해 소스 코드를 수정할 필요가 없게 설계되었다.  
하지만, MTE는 태그를 메모리 시스템에서 가져와 저장해야 하기에 오버헤드를 필연적으로 발생시킨다.
이 오버헤드는 메모리 할당의 생명 주기와 크기, 태그와 데이터가 함께 혹은 개별적으로 조작되는지에 따른 여부와 관계있다.  
오버헤드는 다음과 같은 방법으로 최소화된다.

### 태그 쓰기와 메모리 초기화를 동시에

많은 케이스에서, 메모리는 0으로 초기화되어야 하며 태그도 세팅되어야 한다. 예를 들어, 사용자 공간에 페이지를 전달하기 전에 OS 커널에서 페이지를 지운다. Arm의 리눅스 기반 프로토타입은 이 목적을 위해 STZGM 명령을 사용한다.

### 데이터가 기록되지 않는 주소 공간을 과할당하는 것을 피하기

몇 사례에서, 소프트웨어는 필요한 것보다 훨씬 많은 주소 공간을 할당하며 할당해제 전 일부만 건드리고 만다. MTE를 사용함으로써, 이러한 것은 더 비싼 비용이 들어가는데 왜냐하면 데이터가 메모리에 한 번도 쓰이지 않더라도, 태그는 쓰여야하기 때문이다.

### 과도한 할당해제 및 재할당 피하기

MTE와 무관하게 할당해제 및 재할당을 히가는 것은 보통 좋은 연습이 될 것이다. 하지만, MTE를 씀으로 인해 증가하는 고정 비용의 증가 때문에, 현존하는 성능 이슈가 증폭될 수 있다.

### 스택에 큰 고정 크기 할당 피하기

스택 내에 크고, 고정된 크기의 할당은 쓰이지 않는 경향이 있다. 예를 들어, PATH_MAX와 같은 고정된 크기의 버퍼들은 상대적으로 짧은 문자열을 담고 있다. 이러한 할당을 피하는 것은 사용되지 않는 반드시 쓰여야 하는 메모리 태그의 양을 줄임으로써 스택을 보호하는 데 드는 오버헤드를 줄일 수 있다.

<a name="fuzzing">fuzzing<a>: 퍼즈 테스팅(Fuzz testing) 또는 퍼징 (fuzzing)은 (종종 자동화 또는 반자동화된) 소프트웨어 테스트 기법으로서, 컴퓨터 프로그램에 유효한, 예상치 않은 또는 무작위 데이터를 입력하는 것이다. 이후 프로그램은 충돌이나 빌트인 코드 검증의 실패, 잠재적인 메모리 누수 발견 등 같은 예외에 대한 감시가 이루어진다. 퍼징은 주로 소프트웨어나 컴퓨터 시스템들의 보안 문제를 테스트하기 위해 사용된다. 이것은 하드웨어나 소프트웨어 테스트를 위한 무작위 테스팅 형식이다.  

**위 내용 중 겹치지 않는 부분만 따로 정리했다.**

**[pdf 링크](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwjI2YfLo7b2AhUUC94KHY-nBbAQFnoECAYQAQ&url=https%3A%2F%2Fwww.linuxplumbersconf.org%2Fevent%2F4%2Fcontributions%2F571%2Fattachments%2F399%2F642%2FMTE_LPC.pdf&usg=AOvVaw2aa-9QWnjnmnkx0E3eLAWM)**  

heap 할당의 태깅을 사용하려면 할당자만이 새 명령들을 사용해야 하며, 나머지 코드는 표준 LDR/STR만을 수행해야 한다.

MTE를 위한 추가된 instruction들은 다음과 같다.

![image](https://user-images.githubusercontent.com/73513005/158526078-e9aa69b1-8df1-4ca3-b262-331507706585.png)
