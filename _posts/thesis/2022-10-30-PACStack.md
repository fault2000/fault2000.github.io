---
layout: post
title: PACStack, an Authenticated Call Stack 리뷰
category: [thesis, security]
tags: [thesis, library]
fullview: true
comments: true
use_math: true
author: fault2000
---

# 2022-10-30-PACStack

[PACStack, an Authenticated Call Stack](https://www.usenix.org/system/files/sec21summer_liljestrand.pdf)

## 1. Introduction

기존 코드 삽입 공격은 실행 가능한 메모리 수정을 방지하는 W⊕X의 존재 때문에 비효율적이다. 하지만, 코드 재사용 공격은 프로그램의 실행 가능한 코드 영역을 수정하지 않고 프로그램의 런타임 행동을 변경할 수 있다. Return-oriented programming(ROP)는 프로그램의 control flow를 하이젝킹하기 위해 함수 리턴 주소를 오염시키는 평범한 공격 기술이다. ROP는 피해자 프로그램의 기존 코드 순서를 함께 연결함으로써 [튜링완전](http://wiki.hash.kr/index.php/%ED%8A%9C%EB%A7%81%EC%99%84%EC%A0%84#:~:text=%ED%8A%9C%EB%A7%81%EC%99%84%EC%A0%84(Turing%2DComplete),%EC%9C%BC%EB%A1%9C%20%ED%92%80%20%EC%88%98%20%EC%9E%88%EB%8B%A4%EB%8A%94%20%EA%B2%83%EC%9D%B4%EB%8B%A4.) 계산을 달성하는데 사용될 수 있다. ROP를 방지하기 위해, 리턴 주소는 메모리에 저장될 때 반드시 보호되어야 한다. 현재, ROP를 상대하는 가장 강력한 보호는 각 리턴 주소의 안전한 레퍼런스 복제들을 유지하는 무결성이 보호되는 쉐도우 스택을 사용하는 것이다. 쉐도우 스택의 무결성은 메모리에서 위치를 무작위화하거나 특수한 하드웨어를 사용하여 공격자가 접근할 수 없도록 함으로써 보장되어진다. 최근 소프트웨어 기반 쉐도우 스택은 의미있는 성능을 보여줬지만, 메모리 취약점을 이용하여 쉐도우 스택의 위치를 추론하는 공격자에게 취약하다. 현재까지, Intel CET 같은 오직 하드웨어가 지원하는 전략만이, 보안과 맞바꾸지 않고 무시할 수 있을 정도의 오버헤드를 달성했다. 하지만 이러한 커스텀 하드웨어 메커니즘을 적용하는 것은 개발 및 배치 비용을 발생시킨다.
최근 ARM 프로세서는 pointer authentication(PA) 지원을 포함한다. PA는 조정 가능한 message authentication codes(MACs)을 사용해 포인터에 서명하고 인증하는 하드웨어 확장이다. PA의 초기 사용 사례 중 하나는 리턴 주소의 인증이다. 하지만, 현재 PA 전략은 공격자가 이전에 관측된 유효한 보호된 포인터를 재사용할 수 있는 재사용 공격에 취약하다. 이전 연구와 현재 GCC과 LLVM의 구현은 재사용 공격을 완화시키지만, 완전히 그들을 방지하진 못한다.
이 논문에서, 우리는 authenticated call stack(ACS)라는 최소화된 오버헤드와 새 하드웨어로 보호되는 메모리가 필요하지 않은 하드웨어가 지원하는 쉐도우 스택에 필적하는 보안을 제공하는 새 접근을 제안한다. ACS는 모든 리턴 주소들을 사용되기 전 리턴 주소를 확인하는 MAC 체인으로 묶는다. 우리는 어떻게 ACS가 재사용 공격을 저항하는 동안 ARM PA를 사용해 효율적으로 실현하는지 보여준다. PACSTACK은 완전한 메모리 접근과 함께 강한 공격자를 견뎌낼 수 있다. 우리의 기여는 다음과 같다.

- ACS, MAC을 묶음으로써 함수 리턴 주소의 정확한 인증에 대한 새 접근
- PACStack, 추가적인 하드웨어가 불필요한 ARM PA를 사용한 ACS의 LLVM 기반 실현
- 섀도스택과 유사한 보안성을 나타내는 PACStack 보안의 체계적 평가
- PACStack의 성능 오버헤드가 작다(3%)는 것을 증명

PACStack과 관련된 평가 코드는 오픈 소스로 사용가능하다, [https://pacstack.github.io.](https://pacstack.github.io./)

## 2. Background

### 2.1 ROP on ARM

ROP에서, 공격자는 스택에 저장되어 있는 리턴 주소를 조작함으로써 메모리 취약점을 이용한다. 따라서 프로그램의 backward-edge control flow를 변경할 수 있다. ROP는 여러 가젯, 즉 원하는 작업을 함께 수행하는 기존 프로그램 명령의 공격자가 선택한 시퀀스를 함께 연결함으로써 튜링완전 공격을 허용한다. ARM 아키텍처는 현재 함수의 리턴 주소를 유지하기 위해 link register(LR)을 사용한다. LR은 규칙적이고 간접적인 함수 호출을 구현하는데 사용하는 branch with link(bl) 혹은 branch with link(blr) 명령에 의해 자동적으로 설정된다. LR이 호출 시 덮어쓰여지기 때문에, 자식이 없는 함수는 스택에 리턴 주소를 반드시 보관해야한다. 이는 ARM에서의 ROP 가능성을 연다.

### 2.2 ARM Pointer Authentication

ARMv8.3-A PA 확장은 pointer authentication codes(PACs)을 계싼하고 인증하는 것을 지원한다. PA는 현재 애플 A12, A13, S4, S5 systems-on-chip(SoCs)에 적용되어 있으며, 다가오는 ARMv8.3-A와 이후 SoCs에 사용 가능할 예정이다. pac 명령은 64 bit modifier(수식자) M을 수정으로 사용하여 포인터 P의 주소 AP A*p* check

### 2.2.1 PA-based return address protection

PA 기반 호출 주소 보호는 GCC와 LLVM/-Clang의 -mbranch-protection 기능의 일부로써 구현되었다. 인증된 리턴 주소는 pacasp(in Listing 1)로 산출되어지고 retaa로 인증된다. 이 명령은 명령 키 A를, 수정자로 stack pointer(SP)의 값을 사용한다. PA 키는 하드웨어로 보호되며, 결과적으로 공격자는 수정된 리턴 주소를 위한 정확한 PAC을 유추하는데 의존해야만 한다.
-mbranch-protection 기능과 다른 이전 PA 기반 해결책들은 공격자가 프로세스 메모리에서부터 이전에 읽어들인 다른 인증된 리턴 주소와 유효한 인증된 리턴 주소로 바꾸는 재사용 공격에 취약했다. 인증을 통과하기 위해 PAC을 재사용하기 위해서, 기존 및 교체될 PAC은 같은 PA 키와 수정자를 사용하여 산출되어야 한다. 이는 PA 전략뿐만 아니라 인증된 리턴 주소에도 적용된다. SP 값을 수정자로 사용하는 것은 교체할 수 있는 포인터의 집합을 줄이지만, SP 값이 일치할 경우 재사용 공격을 허용한다. 수정자 값의 범위를 더욱 좁혀 재사용 공격을 완화시킬 수는 있으나, 완전히 방지할 수는 없다.

![https://user-images.githubusercontent.com/73513005/199228220-93d839ed-9f7a-4ce9-bb84-7983d28fd1e2.png](https://user-images.githubusercontent.com/73513005/199228220-93d839ed-9f7a-4ce9-bb84-7983d28fd1e2.png)

## 3. Adversary model and requirements

 이 연구에서, 우리는 강력한 공격자를 고려했다, A, 프로세스 메모리를 임의로 조종할 수 있지만 코드 페이지의 수정을 방지하는 W⊕X 정책에 의해 제한되는 공격자이다. 이 공격 모델은 런타임 공격에 대한 이전 연구들로 구성되었다. 우리는 A를 유저 공간으로 제한했으며, 따라서 A는 PA 키같은 커널이 관리하는 레지스터를 읽거나 수정할 수 없다.
우리는 시스템에 대해 다음과 같은 가정을 만들었다.

A1. W⊕X 전책은 권한이 없는 프로세스에 의한 수정으로부터 코드 메모리 페이지를 보호한다. ARMv8-A를 포함한 모든 주요 프로세서 아키텍처는 W⊕X를 지원한다.

A2. forward control-flow를 제한하는 Coarse-grained forward-edge control-flow integrity(CFI)는 유효한 목표의 집합을 전송한다. 자세히는, 우리는 간접적인 함수 호출이 언제나 함수의 시작을 목표로 함을, 이러한 임의의 주소를 향한 간접적인 점프가 불가능함을 가정했다. 이 속성은 ARM PA, branch target indicators, TrustZone-M과 같은 하드웨어 지원 메커니즘을 사용하여 무시할 수 있는 오버헤드뿐만 아니라 합리적인 오버헤드를 가진 여러 기존 소프트웨어 전용 CFI 해결책에 의해 만족되어졌다. 특히, 상수(예를 들어 0x0) 수정자를 사용한 최소한의 PA 전략도 이 가정을 만족한다.

 이 공격 모델은 A가 데이터 메모리 페이지에 있는 어떠한 포인터도 수정할 수 있게 한다. 특히, A는 함수의 리턴 주소가 프로그램의 콜 스택에 상주하는 동안 수정할 수 있다. 위 목록의 특징은 A가 ACS 명령(Section 6.3)을 손을 대는 것을 방지한다. 우리의 목표는 프로그램의 control-flow를 장악하기 위해 함수 리턴 주소를 수정하는 A를 좌정시키는 것이다. 우리는 다음과 같은 준비 사항을 정의한다.  

R1. 리턴 주소 무결성: 메모리에 있는 동안 함수 리턴 주소가 수정되었는지 감지한다.

R2. 메모리 노출 저항력: A가 전체 프로세스 주소 공간을 읽을 수 있을 때에도 효과적으로 남을 수 있다.

R3. 호환성: 소스 코드 수정 없이 통상적인(규격에 준거한) C 코드에 적용가능해야한다.

R4. 성능: 1~3을 충족하면서 오직 최소한의 런타임 성능 및 메모리 오버헤드를 필요로 해야한다.

 CFI에 대한 이전 연구들 처럼, 우리는 data-oriented programming(DOP) 같은 non-control data 공격에 대해 고려하지 않는다.

## 4. Design: authenticated call stack

 이 영역에서 우리는 authenticated call stack(ACS)를 위한 우리의 일반적인 디자인을 소개한다. Section 5에서, 우리는 ARM PA를 사용해 ACS를 효과적으로 시행한 우리의 구현을 소개한다. 우리의 주요 아이디어는 리턴 주소에게 호출 스택에 있는 모든 이전 리턴 주소들을 암호적으로 묶어 수정자로 주는 것이다. 이는 수정자를 특정 control-flow 경로에 정적으로 특별하게 만들며, 따라서 재사용 타입의 공격을 막고 정확한 리턴 주소 인증을 허용한다.  

 이 리턴 주소 $ret_i,i ∈ [0,n]$(여기서 n은 활성 함수 기록 관점에서 호출 스택의 깊이이다) 은 A가 메모리 취약점을 이용해 그들을 수정할 수 있는 스택에 저장되어져야만 한다. ACS는 마지막 $auth_n$과 스택에 저장된(Figure 2) 모든 리턴 주소 $ret_i , i ∈ [0, n − 1]$를 암호적으로 묶은 일련의 묶인 인증 토큰 $auth_i,i ∈ [0,n]$을 산출하여 이 값들을 보호한다. 오직 MAC 키와 마지막 인증 토큰인 $auth_n$만이 이전 *auth* 토큰과 리턴 주소가 호출 스택을 푸는 동안 정확히 인증될 수 있도록 보장하기 위해 안전하게 보관되어져야 한다(R1). 우리는 b-bit 인증 토큰 $auth_i$를 생성하기 위해 수정 가능한 MAC 함수 $H_K$를 사용한다.

$$
auth_i=
\begin{cases}
  H_K(ret_i,auth_{i-1}) &\text{if }i>0 \\
  H_K(ret_i,0) &\text{if }i=0
\end{cases}
$$

 $auth_n$은 A에 의해 수정되어질 수 없는 레지스터에 유지된다. Figure 3는 어떻게 인증 토큰과 리턴 주소가 호출 스택에 저장되어지는지 보여준다. 함수 호출 시, $auth_i$는 호출 동안 호출자에 의해 유지되어지며, 호출자는 $auth_{i+1}$을 계산하고 $auth_i$와 상응하는 반환 주소 $ret_{i+1}$를 스택 프레임에 전부 저장한다. 리턴 시, $auth’_{i-1}$와 $ret’_i$ 값은 스택으로부터 불러와진 뒤 $H_K(auth’_{i-1}, ret’_i)$와 $auth_i$를 비교하여 인증되어진다. 만약 결과가 다르다면, 하나 혹은 두 불러와진 값이 오염되어진 것이다(R1). 그렇지 않다면, 그들은 유효하다. 예를 들어, $auth’_{i-1}=auth_{i-1}$와 $ret’_i=ret_i$. 이 경우 $auth_i$는 함수가 $ret_i$로 리턴되기 전 보안 레지스터로 인증된 $auth_{i-1}$로 대체된다.  

 간결성을 위해서, 우리는 $auth_i$와 $ret_i$를 합쳐 인증된 리턴 주소인 $aret_i$로 결합할 수 있다.

$$
aret_i=
auth_i || ret_i, where \\
auth_i=
\begin{cases}
H_K(ret_i,aret_{i-1}) &\text{if }i>0 \\
H_K(ret_i,0) &\text{if }i=0
\end{cases}
$$

우리는 만약 주어진 $aret_{i-1}$에 대해 $auth_i=H_K(ret_i, aret_{i-1})$ 라면 $auth_i$와 그에 상응하는 $aret_i$을 유효하다고 부른다.

### 4.1 Securing the authentication token

 현재 인증된 리턴 주소 $aret_n$는 우리가 chain register(CR)이라고 부르는 CPU 레지스터에 독점적으로 저장됨으로써 보호된다. 레지스터를 독점적으로 예약하는 것은 64-bit ARM 아키텍처를 위한 현재 쉐도우 스택 구현에도 필요한 준비 사항이며, x86 아키텍처에서 쉐도우 스택을 위해 제안되어졌던 것임을 기억하자.  

 ACS는 backward-edge control-flow 전송의 무결성을 보호한다. 이를 coarse-grained forward-edge CFI(Assumption A2)와 합침으로써,다음을 보장한다.  

1. 함수 리턴 직후, CR속 $aret_n$가 유효함
2. 함수 시작 시 CR에 저장된 $aret_{n-1}$이 유효함
3. CR은 항상 유효한 $aret$로 설정되거나 사용된다

 이는 토큰 업데이트를 안전하게 수행됨을 보장하고, ACS 계측이 우회되거나 임의로 인증된 리턴 주소를 생성하는데 사용되어질 수 없다.

### 4.2 Mitigating hash-collisions

 $aret_n$이 하드웨어로 보호되긴 하지만, 인증 토큰 $auth$의 크기 b가 구현에 의해 제한될 수 있다. PAC을 토큰으로 사용하는 것은 보통 16 bits로 제한된다. A가 평균적으로 약 $1.253\cdot2^{b/2}$ 토큰을 본 후 충돌이 발견될 수 있기 때문에 이것은 중요하다(b=16일때 321 토큰). 이럼에도 불구하고, 우리는 여전히 A가 충돌(R2)을 인식하지 못하도록 할 수 있으며, 따라서 A는 인증된 리턴 주소가 충돌을 발생시키는 것을 성공 확률 $2^{-b}$로 추측하도록 할 수 있다. 스택에 저장되는 모든 $aret$의 $auth$는 이전 aret 값으로부터 파생된 유사-랜덤 값을 사용하여 마스킹된다.  

$$
auth_i=H_K(ret_i,aret_{i-1})\oplus H_K(0,aret_{i-1}).
$$

 이 마스크는 생성된 후와 인증되기 전 $H_K(ret_i,aret_{i-1})$와 배타적 논리합된다. 그렇게 함으로써 A가 포인터 재사용을 위한 기회를 알아차리는 것을 방지한다. 우리는 마스킹의 보안에 대해 6.2.1에서 논의할 것이다.

### 4.3 Mitigating brute-force guessing

 A가 $auth$ 토큰을 유추하기 위한 브루트 포스 공격은 실패한 추측이 프로그램을 종료하고 후속 프로그램이 새 키를 사용하여 auth 토큰을 생성하는 경우 $b$-bit $auth$에 대한 확률 p를 가지면 $\frac {\log(1-p)} {\log(1-2^{-b})}$번의 추측 후 성공한다. 이 가정은 이전 PA 기반 해결책들과 비슷하며, Linux 5.0의 현재 PA 행동과 일관된다.  

 하지만, 사전 예약 혹은 다중 스레드 프로그램이 키를 공유한다면, A는 사촌 지간의 취약점을 목표로 삼을 수 있다. 실패한 인증이 모든 프로세스 트리를 종료하지 않는 이상, A는 키를 초기화시키지 않고 또다른 사촌 프로세스를 상대로 새 추측을 시도할 수 있다. 이 시나리오에서, 평균적으로 $2^{b-1}$ 추측이 포인터와 인증 토큰의 어떤 조합이 유효한 경우 수정자를 얻기 위해 충분하다. 수정자가 다음 인증된 리턴 주소가 되기 때문에, 주입된 주소를 사용하기 위해 프로세스가 반복될 수 있다. 두 추측은 분할 정복 전략을 사용하여 개별적으로 수행될 수 있기 때문에, 이것은 A가 임의의 주소로 점프하기 위해 추측이 개별적일 때 $2^{2b}$인 것에 비해 평균 $2^b$ 개의 추측이 필요하다.  

 정리하다보니 노잼이라 이만 줄인다.