---
layout: post
title: PACStack, an Authenticated Call Stack 리뷰
category: [thesis, security]
tags: [thesis, library]
fullview: true
comments: true
use_math: true
author: fault2000
---

[PACStack, an Authenticated Call Stack](https://www.usenix.org/system/files/sec21summer_liljestrand.pdf)

## Introduction

 기존 코드 삽입 공격은 실행 가능한 메모리 수정을 방지하는 W⊕X의 존재 때문에 비효율적이다. 하지만, 코드 재사용 공격은 프로그램의 실행 가능한 코드 영역을 수정하지 않고 프로그램의 런타임 행동을 변경할 수 있다. Return-oriented programming(ROP)는 프로그램의 control flow를 하이젝킹하기 위해 함수 리턴 주소를 오염시키는 평범한 공격 기술이다. ROP는 피해자 프로그램의 기존 코드 순서를 함께 연결함으로써 [튜링완전](http://wiki.hash.kr/index.php/%ED%8A%9C%EB%A7%81%EC%99%84%EC%A0%84#:~:text=%ED%8A%9C%EB%A7%81%EC%99%84%EC%A0%84(Turing%2DComplete),%EC%9C%BC%EB%A1%9C%20%ED%92%80%20%EC%88%98%20%EC%9E%88%EB%8B%A4%EB%8A%94%20%EA%B2%83%EC%9D%B4%EB%8B%A4.) 계산을 달성하는데 사용될 수 있다. ROP를 방지하기 위해, 리턴 주소는 메모리에 저장될 때 반드시 보호되어야 한다. 현재, ROP를 상대하는 가장 강력한 보호는 각 리턴 주소의 안전한 레퍼런스 복제들을 유지하는 무결성이 보호되는 쉐도우 스택을 사용하는 것이다. 쉐도우 스택의 무결성은 메모리에서 위치를 무작위화하거나 특수한 하드웨어를 사용하여 공격자가 접근할 수 없도록 함으로써 보장되어진다. 최근 소프트웨어 기반 쉐도우 스택은 의미있는 성능을 보여줬지만, 메모리 취약점을 이용하여 쉐도우 스택의 위치를 추론하는 공격자에게 취약하다. 현재까지, Intel CET 같은 오직 하드웨어가 지원하는 전략만이, 보안과 맞바꾸지 않고 무시할 수 있을 정도의 오버헤드를 달성했다. 하지만 이러한 커스텀 하드웨어 메커니즘을 적용하는 것은 개발 및 배치 비용을 발생시킨다.  
 최근 ARM 프로세서는 pointer authentication(PA) 지원을 포함한다. PA는 조정 가능한 message authentication codes(MACs)을 사용해 포인터에 서명하고 인증하는 하드웨어 확장이다. PA의 초기 사용 사례 중 하나는 리턴 주소의 인증이다. 하지만, 현재 PA 전략은 공격자가 이전에 관측된 유효한 보호된 포인터를 재사용할 수 있는 재사용 공격에 취약하다. 이전 연구와 현재 GCC과 LLVM의 구현은 재사용 공격을 완화시키지만, 완전히 그들을 방지하진 못한다.  
 이 논문에서, 우리는 authenticated call stack(ACS)라는 최소화된 오버헤드와 새 하드웨어로 보호되는 메모리가 필요하지 않은 하드웨어가 지원하는 쉐도우 스택에 필적하는 보안을 제공하는 새 접근을 제안한다. ACS는 모든 리턴 주소들을 사용되기 전 리턴 주소를 확인하는 MAC 체인으로 묶는다. 우리는 어떻게 ACS가 재사용 공격을 저항하는 동안 ARM PA를 사용해 효율적으로 실현하는지 보여준다. PACSTACK은 완전한 메모리 접근과 함께 강한 공격자를 견뎌낼 수 있다. 우리의 기여는 다음과 같다.  

 - ACS, MAC을 묶음으로써 함수 리턴 주소의 정확한 인증에 대한 새 접근
 - PACStack, 추가적인 하드웨어가 불필요한 ARM PA를 사용한 ACS의 LLVM 기반 실현
 - 섀도스택과 유사한 보안성을 나타내는 PACStack 보안의 체계적 평가
 - PACStack의 성능 오버헤드가 작다(3%)는 것을 증명

 PACStack과 관련된 평가 코드는 오픈 소스로 사용가능하다, [https://pacstack.github.io.](https://pacstack.github.io.)  

## Background

### ROP on ARM

 ROP에서, 공격자는 스택에 저장되어 있는 리턴 주소를 조작함으로써 메모리 취약점을 이용한다. 따라서 프로그램의 backward-edge control flow를 변경할 수 있다. ROP는 여러 가젯, 즉 원하는 작업을 함께 수행하는 기존 프로그램 명령의 공격자가 선택한 시퀀스를 함께 연결함으로써 튜링완전 공격을 허용한다. ARM 아키텍처는 현재 함수의 리턴 주소를 유지하기 위해 link register(LR)을 사용한다. LR은 규칙적이고 간접적인 함수 호출을 구현하는데 사용하는 branch with link(bl) 혹은 branch with link(blr) 명령에 의해 자동적으로 설정된다. LR이 호출 시 덮어쓰여지기 때문에, 자식이 없는 함수는 스택에 리턴 주소를 반드시 보관해야한다. 이는 ARM에서의 ROP 가능성을 연다.  

### ARM Pointer Authentication

 ARMv8.3-A PA 확장은 pointer authentication codes(PACs)을 계산하고 인증하는 것을 지원한다. PA는 현재 애플 A12, A13, S4, S5 systems-on-chip(SoCs)에 적용되어 있으며, 다가오는 ARMv8.3-A와 이후 SoCs에 사용 가능할 예정이다. pac 명령은 64 bit modifier(수식자) M을 수정으로 사용하여 포인터 P의 주소 AP $A_p$를 통해 키 조정이 가능한 MAC인 $H_K(A_P, M)$를 계산한다. PAC으로 불리는 결과 인증 토큰은 P의 사용되지 않는 상위 비트에 내장된다. PAC은 $H_K(A_P, M)$를 재계산하고, P의 PAC과 결과를 비교하는 aut 명령을 사용하여 인증될 수 있다.  
 PAC이 포인터의 사용되지 않는 비트에 저장되어지기 때문에, PAC의 크기는 가상 주소 크기(VA_SIZE in Figure 1)와 주소 태깅이 활성화되어 있는지에 따라 제한된다. 기본 리눅스 커널을 실행하는 64-bit ARM 머신에서, VA_SIZE는 39이며, 이는 예약된 비트 및 주소 태그 비트를 제외할 때 PAC에게 16 bit를 남긴다. PA는 5개의 다른 키들을 제공한다. 2개는 코드 포인터, 2개는 데이터 포인터, 마지막 하나는 포괄적인 사용에 쓰인다. 각 키는 개별적인 명령의 집합을 가진다. 예를 들어 autia와 pacia 명령은 APIAKEY_EL1 레지스터에 보관된 명령 키 A에서 항상 작동한다. 키 레지스터와 PA 설정 레지스터에 접근하는 것은 더 높은 exception level(EL)에 의해 제한될 수 있다. 리눅스 v5.0은 커널(at EL1)이 유저 영역(EL0) 키를 관리하고 EL0가 수정되어지는 것을 방지하는 PA에 대한 모든 지원을 추가했다. 커널은 exec 시스템 호출 때 프로세스를 위한 새 PA 키를 생성한다.  
 