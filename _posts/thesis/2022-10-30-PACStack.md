---
layout: post
title: PACStack, an Authenticated Call Stack 리뷰
category: [thesis, security]
tags: [thesis, library]
fullview: true
comments: true
use_math: true
author: fault2000
---

[PACStack, an Authenticated Call Stack](https://www.usenix.org/system/files/sec21summer_liljestrand.pdf)

## Introduction

 기존 코드 삽입 공격은 실행 가능한 메모리 수정을 방지하는 W⊕X의 존재 때문에 비효율적이다. 하지만, 코드 재사용 공격은 프로그램의 실행 가능한 코드 영역을 수정하지 않고 프로그램의 런타임 행동을 변경할 수 있다. Return-oriented programming(ROP)는 프로그램의 control flow를 하이젝킹하기 위해 함수 리턴 주소를 오염시키는 평범한 공격 기술이다. ROP는 피해자 프로그램의 기존 코드 순서를 함께 연결함으로써 [튜링완전](http://wiki.hash.kr/index.php/%ED%8A%9C%EB%A7%81%EC%99%84%EC%A0%84#:~:text=%ED%8A%9C%EB%A7%81%EC%99%84%EC%A0%84(Turing%2DComplete),%EC%9C%BC%EB%A1%9C%20%ED%92%80%20%EC%88%98%20%EC%9E%88%EB%8B%A4%EB%8A%94%20%EA%B2%83%EC%9D%B4%EB%8B%A4.) 계산을 달성하는데 사용될 수 있다. ROP를 방지하기 위해, 리턴 주소는 메모리에 저장될 때 반드시 보호되어야 한다. 현재, ROP를 상대하는 가장 강력한 보호는 각 리턴 주소의 안전한 레퍼런스 복제들을 유지하는 무결성이 보호되는 쉐도우 스택을 사용하는 것이다. 쉐도우 스택의 무결성은 메모리에서 위치를 무작위화하거나 특수한 하드웨어를 사용하여 공격자가 접근할 수 없도록 함으로써 보장되어진다. 최근 소프트웨어 기반 쉐도우 스택은 의미있는 성능을 보여줬지만, 메모리 취약점을 이용하여 쉐도우 스택의 위치를 추론하는 공격자에게 취약하다. 현재까지, Intel CET 같은 오직 하드웨어가 지원하는 전략만이, 보안과 맞바꾸지 않고 무시할 수 있을 정도의 오버헤드를 달성했다. 하지만 이러한 커스텀 하드웨어 메커니즘을 적용하는 것은 개발 및 배치 비용을 발생시킨다.  
 최근 ARM 프로세서는 pointer authentication(PA) 지원을 포함한다. PA는 조정 가능한 message authentication codes(MACs)을 사용해 포인터에 서명하고 인증하는 하드웨어 확장이다. PA의 초기 사용 사례 중 하나는 리턴 주소의 인증이다. 하지만, 현재 PA 전략은 공격자가 이전에 관측된 유효한 보호된 포인터를 재사용할 수 있는 재사용 공격에 취약하다. 이전 연구와 현재 GCC과 LLVM의 구현은 재사용 공격을 완화시키지만, 완전히 그들을 방지하진 못한다.  
 이 논문에서, 우리는 authenticated call stack(ACS)라는 최소화된 오버헤드와 새 하드웨어로 보호되는 메모리가 필요하지 않은 하드웨어가 지원하는 쉐도우 스택에 필적하는 보안을 제공하는 새 접근을 제안한다. ACS는 모든 리턴 주소들을 사용되기 전 리턴 주소를 확인하는 MAC 체인으로 묶는다. 우리는 어떻게 ACS가 재사용 공격을 저항하는 동안 ARM PA를 사용해 효율적으로 실현하는지 보여준다. PACSTACK은 완전한 메모리 접근과 함께 강한 공격자를 견뎌낼 수 있다. 우리의 기여는 다음과 같다.  

 - ACS, MAC을 묶음으로써 함수 리턴 주소의 정확한 인증에 대한 새 접근
 - PACStack, 추가적인 하드웨어가 불필요한 ARM PA를 사용한 ACS의 LLVM 기반 실현
 - 섀도스택과 유사한 보안성을 나타내는 PACStack 보안의 체계적 평가
 - PACStack의 성능 오버헤드가 작다(3%)는 것을 증명

 PACStack과 관련된 평가 코드는 오픈 소스로 사용가능하다, [https://pacstack.github.io.](https://pacstack.github.io.)  

## Background

### ROP on ARM

 ROP에서, 공격자는 스택에 저장되어 있는 리턴 주소를 조작함으로써 메모리 취약점을 이용한다. 따라서 프로그램의 backward-edge control flow를 변경할 수 있다. ROP는 여러 가젯, 즉 원하는 작업을 함께 수행하는 기존 프로그램 명령의 공격자가 선택한 시퀀스를 함께 연결함으로써 튜링완전 공격을 허용한다. ARM 아키텍처는 현재 함수의 리턴 주소를 유지하기 위해 link register(LR)을 사용한다. LR은 규칙적이고 간접적인 함수 호출을 구현하는데 사용하는 branch with link(bl) 혹은 branch with link(blr) 명령에 의해 자동적으로 설정된다. LR이 호출 시 덮어쓰여지기 때문에, 자식이 없는 함수는 스택에 리턴 주소를 반드시 보관해야한다. 이는 ARM에서의 ROP 가능성을 연다.  

### ARM Pointer Authentication

 ARMv8.3-A PA 확장은 pointer authentication codes(PACs)을 계싼하고 인증하는 것을 지원한다. PA는 현재 애플 A12, A13, S4, S5 systems-on-chip(SoCs)에 적용되어 있으며, 다가오는 ARMv8.3-A와 이후 SoCs에 사용 가능할 예정이다. pac 명령은 64 bit modifier(수식자) M을 수정으로 사용하여 포인터 P의 주소 AP $A_p$ check

#### PA-based return address protection

 PA 기반 호출 주소 보호는 GCC와 LLVM/-Clang의 -mbranch-protection 기능의 일부로써 구현되었다. 인증된 리턴 주소는 pacasp(in Listing 1)로 산출되어지고 retaa로 인증된다. 이 명령은 명령 키 A를, 수정자로 stack pointer(SP)의 값을 사용한다. PA 키는 하드웨어로 보호되며, 결과적으로 공격자는 수정된 리턴 주소를 위한 정확한 PAC을 유추하는데 의존해야만 한다.  
 -mbranch-protection 기능과 다른 이전 PA 기반 해결책들은 공격자가 프로세스 메모리에서부터 이전에 읽어들인 다른 인증된 리턴 주소와 유효한 인증된 리턴 주소로 바꾸는 재사용 공격에 취약했다. 인증을 통과하기 위해 PAC을 재사용하기 위해서, 기존 및 교체될 PAC은 같은 PA 키와 수정자를 사용하여 산출되어야 한다. 이는 PA 전략뿐만 아니라 인증된 리턴 주소에도 적용된다. SP 값을 수정자로 사용하는 것은 교체할 수 있는 포인터의 집합을 줄이지만, SP 값이 일치할 경우 재사용 공격을 허용한다. 수정자 값의 범위를 더욱 좁혀 재사용 공격을 완화시킬 수는 있으나, 완전히 방지할 수는 없다.  

## Adversary model and requirements

 이 연구에서, 우리는 강력한 공격자를 고려했다, A, 프로세스 메모리를 임의로 조종할 수 있지만 코드 페이지의 수정을 방지하는 W⊕X 정책에 의해 제한되는 공격자이다. 이 공격 모델은 런타임 공격에 대한 이전 연구들로 구성되었다. 우리는 A를 유저 공간으로 제한했으며, 따라서 A는 PA 키같은 커널이 관리하는 레지스터를 읽거나 수정할 수 없다.  
 우리는 시스템에 대해 다음과 같은 가정을 만들었다.  

 A1 