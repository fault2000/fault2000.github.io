---
layout: post
title: PTAuth, Temporal Memory Safety via Robust Points-to Authentication 리뷰
categories: [thesis]
tags: [thesis, stack-based memory, randomizing]
fullview: true
comments: true
use_math: true
author: fault2000
---

이번 논문은 그리 어려운 내용이 아니므로, 저번 논문 리뷰처럼 하나하나 번역하는 수준이 아닌 내가 원하는 부분만 요약 정리해보았다.  

### Introduce

먼저 이 논문은 Temporal 공격을 방어하는데 사용되는 방어 기법들이 제한된 범위의 방어와 큰 오버헤드가 유발되고, 메타데이터를 보호하기 위해 외부 기법(e.g. spatial 메모리 안전)이 필요하기에 방어가 우회될 수 있다는 단점을 극복하고자 robust points-to authentication을 소개하고 있다.  

여기서 소개하는 temporal 공격의 종류는 크게 세 가지이다.

1. Use-after-free
2. Double-free
3. Invalid-free

![image](https://user-images.githubusercontent.com/73513005/152136959-29743184-b35c-468b-86a4-433eff788f19.png)

위 예시를 논문에서는 제시해주고 있다. 첫 번째는 ptr이 free 되었음에도, 별칭인 qtr이 남아 사용되는 모습을 볼 수 있다.  
두 번째는 ptr이 free되고, 후에 별칭인 qtr이 한 번 더 free되는 모습을 볼 수 있다.  
세 번째는 ptr이 for문을 통해 ++되는 모습이 보이는데, 이를 통해 포인터가 목표의 첫 부분이 아니라 마지막 부분을 가리키는 동안 free되는 경우이다.  

또한 이 PTAuth는 PAC(Pointer Authentication Code)이라는 ARMv8.3-A와 ARM Cortex-A 아키텍쳐에서 지원하는 새 하드웨어 기능을 사용한다. PAC은 중요한 포인터의 무결성을 체크하도록 디자인되었으며, 컴파일러나 프로그래머가 맞는 PAC 명령을 사용하여 (1) 선택된 포인터에 대한 서명을 만들고, (2) 서명된 포인터가 사용될 때 서명을 확인한다.  
작동 방식은 두 64-bit 입력(포인터, context 값)을 받아 입력을 128-bit key로 암호화한다. 이를 통해 나온 결과는 64-bit 서명을 출력한다. 서명은 잘려져 포인터의 안쓰이는 비트에 저장된다. 여기서 쓰이는 context는 프로그래머나 컴파일러가 각 포인터마다 선택할 수 있다. 
그러나 최근 UAF 공격(CVE-2019-8605)은 이러한 PAC이 temporal 공격에 대항할 수 없음이 알려졌다. 이를 보완하기 위해 PTAuth가 사용될 것이다.

### OverView

temporal 공격을 감지하기 위해서 1) 포인터가 현재 혹은 의도된 객체를 가리키는지, 2) 포인터가 가리키는 관계가 진짜인지 입증하는 메타데이터 혹은 증거를 체크해야 한다.  
개념은 명확함에도, 이를 위한 효율적이고 보안적인 방법은 도전적이다. 어떤 메타데이터가 points-to 관계를 설립하는데 필요한가? 어떻게 메타데이터가 산출되고 어디에 그들이 저장되는가? 그들의 무결성이 어떻게 검사될 것인가? 이러한 질문에 대한 대답이 PTAuth의 효울성과 강력함을 결정할 것이다.  

PTAuth의 대략적인 작동 구조는 다음과 같다.  
PTAuth는 할당 시 각 heap 객체의 ID를 무작위적으로 생성한다. 또한 cryptographic authentication code(AC)를 객체 ID와, 객체의 base address로 산출할 것이다.  
객체 ID는 객체의 시작 부분에 저장되고, AC는 객체 포인터에 사용되지 않는 bits에 저장될 것이다. 이 둘은 함께 객체와 포인터 사이에 points-to 관계를 설정하기 위한 메타데이터 역할을 한다.  

PTAuth는 위에서 소개했던 ARM의 PAC 특징을 활용할 것이다. AC를 산출하고 검사하면서 동시에 보호하는 역할을 하는 하드웨어에서 제공되는 간단한 형태로 사용할 것이다.

#### Points-to Authentication Scheme

인증 체계는 두 타입의 데이터에 적용된다. 객체와 데이터 포인터이다.  
이 논문에선, heap 객체들에 대한 포인터만 다룰 것이다. PTAuth는 포인터를 통해 접근하기 전 모든 객체의 ID와 points-to 관계을 검증한다. 이 검증은 AC에 의존한다.  

![image](https://user-images.githubusercontent.com/73513005/152241312-b260c3ba-66ee-4c17-a17f-e854cbb6e752.png)

위 그림은 AC와 ID가 저장되는 모습을 보여준다. 객체의 ID는 메모리의 객체 바로 앞에 인라인 메타데이터로 저장된다.  
ID는 객체가 배치될 때 생성되는 64-bit 무작위 값이다. AC는 16-bit 크기이고 pointer의 사용되지 않는 비트에 저장된다.
**Data Pointers**: 앞에서 살펴봤듯 AC는 객체의 ID와 base 주소를 통해 만들어지므로 객체의 시간적, 공간적 독특한 신분을 만든다. 위 그림 왼쪽 아래를 보면 AC를 PACIA 명령을 통해 산출하는 것을 볼 수 있다. 이러한 산출은 객체가 할당될 때 수행된다. 객체가 할당 해제되거나 생명 주기가 끝에 도달하면, PTAuth는 ID를 전부 0으로 설정하여 비활성한다. 각 포인터 역참조마다, PTAuth는 AC를 재산출하고 포인터에 저장된 AC와 비교한다. 비일치는 temporal 메모리 안전 위반을 나타낸다. points-to 인증을 실패하지 않는 temporal 공격은 없다.  
이 연구는 전 연구들보다 메타데이터를 저장하기에 더 적은 메모리를 사용합니다. 더 나아가 메타데이터가 훼손되지 않는다는 가정도 필요가 없습니다. 마지막으로, PTAuth는 PAC의 도움으로 안정적으로 객체의 기본 주소를 찾을 수 있습니다. 포인터 산술 연산자를 지원하기 위해서는 포인터가 포인티의 중간 지점을 가리키도록 변할 수 있는데, 그러면 단순히 포인터의 값을 받으면 원래 객체의 base 주소와 다른 값을 얻게 될 수 있습니다.  
PAC 명령어는 데이터 포인터 키(data.A, data.B)를 통해 입력(객체 ID와 base 주소)를 암호화 및 서명한다. 그리고 AC를 pointer의 사용하지 않는 비트에 저장한다. AC는 객체 할당이나 포인터가 또다른 객체로 재지정될 때 같이 포인터에 새 값을 저장할 때마다 새로 생성된다.  
포인티가 free되어 댕글링 포인터의 역참조가 실행되면, 그 객체는 이미 ID가 0으로 초기화되었거나 새 객체 할당으로 인해 ID가 변경되었을 것이므로 객체 ID 불일치가 일어날 것이다. 다른 temporal 공격도 마찬가지로 감지될 수 있다.  
**Code Pointers**: code 포인터의 무결성을 검사하는 것은 PAC 사용의 의의이고, 상당히 간단하다. data 포인터와 다르게 code 포인터를 위해 AC를 정의하진 않는다. PTAuth는 제어 흐름 하이재킹 공격을 방지하기 위한 code 포인터용 PAC의 의도된 사용과 완전히 부합하다. 즉 이 논문에서는 따로 방어 방식을 제안하진 않는다.  

#### Compiler-based Code Instrumentation & Runtime AC Checking**

PTAuth는 LLVM에 추가된 사용자 지정 컴파일 패스를 통해 프로그램을 계측, 프로그램 실행 중 적절한 순간에 AC를 생성하고 확인할 수 있도록 한다. 아래에서 AC의 각 작동 유형에 필요한 코드 계측에 대해 설명할 것이다.  
**AC Generation**: 실행시간 동안, PTAuth는 새 points-to 관계가 생성될 때마다 데이터 포인터를 위한 AC를 생성해야 한다. 이를 위해, 컴파일 동안, PTAuth는 두 종류의 계측을 수행한다. 먼저, malloc, calloc, realloc 같은 것들이 포함된 모든 필수적인 heap 메모리 할당을 위한 API들을 계측한다. 이 계측은 PTAuth가 모든 메모리 할당을 가로챌 수 있도록 허용하며 여기서 객체 ID가 생성되고 포인터의 AC가 다음과 같이 계산된다.  

![image](https://user-images.githubusercontent.com/73513005/152262780-81e7ecb5-3c8e-40bd-bcd7-f556adad1166.png)

두번째로, PTAuth는 free같은 객체 할당 해제를 계측한다. 객체 할당 해제 시, PTAuth는 객체 ID를 0으로 설정한다.  

**AC Checking**: PTAuth는 포인터 기반 데이터 접근이 발생할 때마다 AC를 검사함으로써 points-to 인증을 수행한다. 컴파일 동안, PTAuth는 포인터를 위한 LLVM load와 GetElementPtr 명령을 계측한다. 간단함을 위해서, 우리는 두 명령을 load라고 통칭할 것이다. PTAuth는 다음을 통해 포인터 값의 AC를 인증하고 포인터의 무결성을 확인한다.

![image](https://user-images.githubusercontent.com/73513005/152265321-ef5ef05e-35db-4118-ba99-6534613b898b.png)

포인터 산술 때문에, 포인터가 기본를 가리키는게 아닌 중앙 부분을 가리킬 수도 있다. 따라서, AC 검사 중에 PTAuth는 포인터의 값을 기본 주소로 사용할 수 없다. 이 문제에 대한 간단한 해결책으로 각 포인터의 객체 기본 주소를 기록하기 위해 추가 메타데이터를 사용하는 것이지만, 이는 공간 오버헤드를 늘릴 뿐만 아니라 포인터가 복사되거나 이동될 때 메타데이터를 전파하는 더 어려운 문제를 야기할 것이다.  

**Backward Search**: PTAuth는 어떤 추가 메타데이터를 필요로 하지 않고 실행 시간 도중 객체의 기본 주소를 찾아낸다. 각 AC 검사를 위해, PTAuth는 기본적으로 객체 기본 주소로 포인터 값을 사용한다. 만약 검사가 실패한다면, 두 가능성이 제기된다. 첫번째로, 포인터는 유효하지만 포인티의 중간을 가리킬 경우이다. 두번째로, 포인터가 유효하지 않고 temporal 메모리 공격이 발생한 경우이다. AC 검사 실패를 맞닥뜨린다면, PTAuth는 첫번째 경우가 발생했다고 가정한다. 그런 다음 객체의 기본을 찾기 위해 현재 포인터 위치로부터 역방향 검색을 시작한다. 객체가 메모리에서 16 바이트 정렬되기에, 역방향 검색은 16으로 나눌 수 있는 객체 기본 주소만 찾는다. 이 최적화는 역방향 검색을 빠르게 해준다. 이 검색은 AC 일치가 발생하거나, 검색이 최대 거리 혹은 무효한 메모리에 도달하면 종료된다. 이 경우 temporal 공격이 발생한 것으로 간주한다.  
우리의 역방향 검색 전략은 잘 작동하지만, 추후 PAC 명령이 인증 실패 시 예외를 발생시킬 수 있으므로, 그럴 경우 kernel 패치를 통해 이를 수정해주어야 할 것이다.  

**Metadata propagation**: AC의 포인터 속 저장에 감사하게도, 포인터가 복사되거나 옮겨질 때, 포인터에 대한 메타데이터는 특별한 방법 없이 자동으로 옮겨진다. 단, 객체의 ID는 객체의 안에 있지 않아 자동으로 옮겨지지 않는데, 이는 의도된 것이다. 객체 ID는 버퍼 속 저장되는 데이터보다는 할당된 버퍼와 관계가 있기 때문이다.  

**Handling deallocation**: 포인터 역참조와는 다르게 할당 해제는 항상 개체의 시작을 가리켜야 한다. 아니라면, invalid-free가 발생하여 정의되지 않은 행동과 temporal 메모리 에러로 이어지기 때문이다. 이러한 사실 때문에, PTAuth는 오직 역방향 기본 주소 검색 없이 한 번의 AC 검사만 수행한다. 만약 할당 해제에서 인증이 실패하면, double-free 혹은 invalid-free가 발생한다.  

**Handling reallocation**: 재할당 동안, 객체의 기본 주소는 객체의 크기와 메모리의 레이아웃에 따라 변경될 수도, 아닐 수도 있다. PTAuth는 realloc 계측을 통해 재할당을 다룬다. 만약 객체의 기본 주소가 바뀌었다면, PTAuth는 옛 객체의 ID를 nullifies 한다. 그리고 새 ID를 생성하고, 새 기본 포인터를 위해 새 AC를 산출한다. 결과적으로, 옛 객체로 향하는 현존하는 포인터는 무효화되고, 다시 사용할 수 없게 된다.  

**External/uninstrumented Code**: 컴파일 시간 동안, PTAuth는 외부적으로 연결된 코드 혹은 계측할 수 없는 코드를 blackbox로 취급한다. PTAuth는 이러한 블랙박스에 항목을 계측하여 객체나 포인터가 블랙박스로 흐르기 바로 전에 PTAuth가 포인터를 인증한 다음 AC를 제거하며 XPAC 명령을 사용하여 효율적으로 수행할 수 있다. 반대로 포인터가 블랙박스로부터 돌아올 때 PTAuth는 그에 대한 AC를 생성하며, 그 이후의 용도는 검사의 대상이 된다.
