---
layout: post
title: Preventing Kernel Hacks with HAKC 리뷰
categories: [thesis]
tags: [thesis, Kernel, monolithic]
fullview: true
comments: true
use_math: true
author: fault2000
---

## INTRODUCTION

최근 커널의 크기와 복잡성이 증가하면서 CVE의 수는 2005년에서 2020년까지 270% 증가했다.  
Loadable kernel modules(LKMs)은 커널이 LKM의 기능이 필요할 때 적제된다. 따라서, 런타임 시 분명하고 논리적 구분이 있으나 monolithic 커널 구현이 이러한 구분을 없앤다.  
모든 코드와 데이터가 같은 주소 공간에 있어 LKM의 버그는 커널 버그와 같다고 취급된다. 예를 들어, 높은 심각도를 가진 CVE중 301개(0.53%)가 drivers/, sound/(대부분의 코드들이 LKM을 위해 존재)에서 발견된다.  
잘 실행된 exploit은 메모리 공간 침범을 하지 않고, 검증된 path로만 진행되기에 control-flow integrity또한 침범하지 않는다. 따라서, 진정한 커널 보안을 위해 구획화가 필요하다.  
현재 최첨단 상용 커널 보호 방법은 가상화 기반, micro-kernel 기반, 컴파일러 기반의 3가지 범주로 구분된다.  
**가상화 기반 보호**는 하이퍼바이저를 사용, 하이퍼바이저를 사용, 실행을 모니터링하거나 싱행 도메인 간에 강한 분리를 제공한다.  
**microkernel 기반 보호**는 os를 완전히 재디자인해 Trusted Computing Base(TCB)를 최소화, 오직 가상 메모리 관리와 IPC만을 가지게 하고, 다른 기존 커널 서비스를 유저 영역 프로세스에 분리한다.  
**컴파일러 기반 보호**는 code-reuse 또는 data-only attacks을 차단하려는 컴파일러의 보안 검사 또는 무작위화를 도입한다.  
가상화와 microkernel 방어는 강한 보호를 제공하나, 더 낮은 성능을 가지며, 추가적인 소프트웨어 TCB에 의존한다. 컴파일러 보호는 KASAN을 제외하고 더 성능이 높으나, attack surface의 부분만을 보호하거나 우회되는 경우가 많다.  
이 논문에서는 Hardware-Assisted Kernel Compartmentalization(HAKC)를 선보인다. 이는 커널 코드와 데이터를 구획화하는 메커니즘을 담고 있다. HAKC은 TCB의 증가를 방지하면서도 데이터와 control-flow 보호를 제공하는 하드웨어 기능에 의존한다. 또한 코드와 데이터를 개발자가 지정한 코드와 데이터가 섞여있는 파티션으로 나누고, 이들을 효율적인 정책 실행을 위해 각 파티션을 더 큰 그룹으로 모은다. 각 파티션에 대해 데이터 정책이 정의되어 있으며, control flow가 구성 파티션 집합을 나가야 하는 경우를 위해 큰 그룹에 대해 제어 정책이 정의되어진다. HAKC는 임의 데이터 접근 및 코드 실행을 방지하기 위해 세분화된 데이터 접근 및 제어 전환 정책을 제공한다. 데이터 접근 정책을 사용하면 모든 데이터가 정확히 하나의 파티션에 속하며 접근된 데이터는 각 파티션에 대해 정의된 데이터 접근 정책을 준수한다. control-transition 정책은 간접 control flow 대상도 파티션 집합 접근 정책을 준수하는지 확인한다. control flow가 파티션 집합을 벗어나면 데이터 소유권이 대상으로 전송된 다음 return 시 복원된다. 이러한 방식으로 HAKC은 안전한 로컬 데이터 접근을 최적화하고 실행한다. 파티션 내의 코드 및 데이터 접근은 외부 데이터에 비해 안전하고 빠르다. 그러나 파티션 외부에 정의된 데이터 및 코드는 명시적으로 필요한 경우에만 접근할 수 있다. HAKC는 LKM을 구획화하는 것을 중심으로 설계되었지만, 사용 사례에만 국한되지 않는다. HAKC는 사용자 공간 코드뿐만 아니라 핵심 커널 코드에도 적용될 수 있다.

## BACKGROUND AND MOTIVATION

PAC과 MTE를 기초 지식으로 가지고 가야한다.  
PAC은 암호로 사인된 포인터에 사용되며, 64-bit pointer에 사인을 '안 사용된' 상위 bits에 저장한다.  
MTE는 메모리 지역에 태그를 할당하여 주소 공간을 구분된 영역으로 분리하는데 사용될 수 있다.  
자세한 내용은 직접 찾아보는 것을 권한다.  
HAKC에 대해, 2015년 1월부터 2021년 5월까지 리눅스 커널용으로 발행된 높은 심각도를 가진(CVSS 3.0 등급 7.0 혹은 그 이상) CVE를 분석했고, 메모리 안전성 또는 구획화로 CVE를 완화할 수 있는지 여부를 결정했다. 분류의 근거는 두 가지 방어 메커니즘에 매핑되는 설명에서 키워드를 검색하거나(임의의 코드 실행은 구획화로, use-after-free는 메모리 안전으로 매핑), 설명이 불분명한 경우 패치의 수동 분석을 통해 결정되었다. 그 결과 567개의 CVE 중 229개는 구획화를 통해, 193개는 메모리 안전성을 통해 완화될 수 있었다. 오직 71개만이 중복되어 완화되었다. 73개가 완화될 수 없다.

## THREAT MODEL

![image](https://user-images.githubusercontent.com/73513005/166225521-2569e8f0-e441-41df-896b-92849a24c774.png)  
Listing 2, 3는 우리의 위협 모델에 적합하지만 임의의 읽기와 쓰기를 제공하는 두 부분적인 LKM 구현의 예이다. Listing 3는 Listing 2에 따라 달라지며, 프로그래머의 의도는 정의된 배열에서 읽기만 하는 것이다. 하지만 idx에 대한 검사가 누락되었기에 사용자가 MSG_PUT 또는 MSG_GET과 [0, SIZE] 범위를 벗어난 인덱스를 사용하여 ioctl을 호출하면 모든 주소를 쓰거나 읽을 수 있다.(페이지 권한 제한). 커널의 단일 설계는 이러한 접근을 허용하지만, HAKC는 두 개의 LKM을 구분함으로써 이러한 접근을 방지한다.

##  HAKC COMPARTMENTALIZATION API AND ENFORCEMENT

HAKC은 두 핵심 기여로 이루어져있으며, 이들이 합쳐질 시 추가 가상화 없이 분리를 설정할 수 있는 기능에 도움을 준다.  
**구획화 정책 API**는 개발자가 코드와 데이터에 대해 세분화된 구획화 정책을 수립할 수 있는 기본 요소를 노출시킨다.  
**구획 실행 메커니즘**은 런타임에 특정 구획화 정책을 효율적으로 시행한다.  
이 두 가지에 대해 상세히 기술한다.  

1. Compartmentalization Policy API
   HAKC의 구획화 정책 API는 개발자들이 구획에 코드와 전역 변수를 할당하는 것을 허락한다. 스택 및 힙 변수는 해당 변수를 할당하는 코드와 동일한 구획에 할당된다. 구획화 정책은 또한 구획 간에 허가된 control flow를 특정한다. 각 구획 간 control flow 전송이 일어나면, 필요한 데이터 또한 자동적으로 전송된다.  
   HAKC 구획화 정책 API는 유저가 다음과 같은 HAKC의 두 단계의 구획화 전략을 설정하도록 허락한다.  
   1.Cluques(clique), 코드와 데이터를 하나 혹은 여러 그룹으로 파티셔닝, 각 함수와 데이터 객체는 한 파티션에 정확히 소속됨  
   2.Compartment(구획), 두 번째 수준 그룹으로 최소한 하나의 clique를 가지며, 각 clique은 정확히 하나의 구획에 소속됨  
   3.clique 접근 정책, 자신을 포함하여 특정한 clique에 접근할 수 있는 구획 속 clique의 집합  
   4.구획 전송 정책, 구획 밖으로 control을 전송할 수 있는 clique의 집합, 검증된 control-flow 목표인 허용된 외부 clique의 집합  
   ![image](https://user-images.githubusercontent.com/73513005/165668190-86012090-b418-4a88-9085-1f5233e55cf8.png)
   위 그림은 구획에 대한 두 예제를 보여준다. 구획 0의 빨간 clique은 빨강, 보라, 파랑, 주황 clique에 접근할 수 있다, 반면 구획 4에서는, 빨강은 오직 자기 자신만 접근할 수 있다.  
   ![image](https://user-images.githubusercontent.com/73513005/165677431-cd86e2ab-83f8-499d-bde0-4e02c7dfe359.png)
   위 그림은 여러 구획들의 종류와 가능한 전송에 대해 설명한다. 구획 0는 구획 1과 4에 control flow를 전송할 수 있지만, 구획 3은 오직 구획 4에만 전송이 가능하다.  
   두 레벨 구획화 정책 API는 3가지 중요한 장점을 제공한다.  
   1. 제한된 숫자의 색만으로 많은 수의 구획을 만들어낼 수 있는 능력: 이는 개발자가 구획화 정책을 설계할 때 범용 태그 하드웨어에 존재하는 제한으로부터 해방되어 기존 $2^{tag}$ 갯수의 비해 더 많은 구획 간 태그를 재사용할 수 있다.
   2. 구획 내의 정의된 데이터에 대한 효율적인 접근: clique이 실행되는 동안, 포인터로 접근되는 모든 데이터는 다음 두 조건을 충족해야 한다. 1. 데이터는 clique가 있는 구획에 속해야 하며 2. 현재 clique가 접근할 수 있는 데이터는 clique에 속해야 한다. 이러한 조건은 함수에서 포인터의 첫 번째 참조를 해제하기 전에 런타임에 확인되지만, 포인터가 수정되지 않는 한 다시 확인하지 않는다. 이 두 조건을 충족하면 임의 데이터 접근이 차단되고, 데이터 소유권이 적용된다. 또한 이러한 조건은 clique 접근 정책만 확인하면 되고 해당 정책은 $2^{tag}$ clique에만 관련되므로, 더 빠른 검사와 구획 접근 정책과 비교하여 매우 최적화된 구현을 허용한다.
   3. 개발자들을 위한 세분화된 성능/안전비 유연성: 이를 설명하기 위해 먼저 clique와 구획 접근 정책의 작동 방식을 설명해야한다. 개발자는 코드와 데이터를 하나 이상의 clique로 분할하고, 각 특정 clique가 합법적으로 접근할 수 있는 clique 및 유효한 제어 흐름 대상인 구획을 결정한다. 특정 구획화 정책은 수동으로 결정하거나 정적 또는 동적 분석을 통해 자동으로 결정할 수 있으며 구획마다 다를 수 있다. 구획의 모든 데이터와 코드는 단 하나의 clique에 속해야 하며, clique 사이의 지시된 화살표는 유효한 접근을 나타낸다. 방향 화살표는 정방향 clique 기반 제어 전송 전책을 나타내며 대칭일 필요는 없다.
   제어 흐름이 직접 또는 간접 함수 호출을 통해 구획을 종료해야 할 경우, 종료된 데이터의 소유권을 대상 목적지로 이전한 다음 return시 복원해야 한다. 이 전송을 통해 clique의 데이터 검사가 의도한 대로 진행되어 유효한 데이터 소유권을 유지할 수 있다. 간접 함수 호출의 경우 대상이 구획에서 정의하는 유효한 전환 정책을 준수하는지, 대상이 대상 구획에 대해 유효한 입구인지 확인한다. 간접 호출 대상이 같은 구획 내에 있을 경우, 현재 clique에 대한 접근 정책을 따라야 하지만 데이터 소유권은 전송되지 않는다. control-flow 검사는 유효한 제어 경로를 따르고 임의 코드가 실행되지 않도록 한다.
   코드와 데이터를 clique와 구획으로 분할하는 방법을 조정함으로써, 개발자는 보안과 성능 사이에 세밀한 trade-off를 할 수 있다. 구획의 수가 증가할수록, 공격자가 clique 접근 정책과 구획 제어-전송 정책을 동시에 따르는 유효한 control-flow 경로를 찾아야 하기에 공격이 어려워진다. 그러나 구획 수가 증가하면 데이터 소유권 전송이 많아지고 이로 인해 성능 오버헤드가 커질 수 있다.
2. Compartmentalization Enforcement Mechanism
   clique 코드가 실행중일 때, HAKC는 추가 TCB에 의존하지 않고, 접근 정책 실행을 위해 하드웨어을 사용한다. 앞선 구획화 메커니즘은 추가적인 가상화 레이어에 의존한다. 그러나 하드웨어에 대한 신뢰를 바탕으로 구획화를 위한 이러한 전면적인 패러다임을 깨면 추상화 계층을 추가하고 TCB를 확장하는 것을 피할 수 있다. HAKC는 현실적이고 상용 하드웨어에 대한 이 과제를 최초로 해결했다.  
   구획화를 제공하기 위해서, HAKC는 가상 주소 공간을 기존 페이징으로부터 개별적으로 파티션할 수 있어야 하며, 포인터를 사용 가능한 주소 공간 파티션보다 큰 비트 크기의 메타데이터와 연결할 수 있는 기능, 즉 포인터와 결합된 메타데이터가 필요하다. 가상 주소 공간 분할은 가상 메모리 주소 범위를 주소 공간의 나머지 부분과 구별되는 방식으로 지정하는 방법을 의미한다. 태그가 달린 아키텍처는 일반적으로 가상 메모리 주소 범위와 연결하거나 색을 입히는 소수의 비트를 제공한다. 로드 시 정적으로 생성되거나 동적으로 할당된 모든 포인터는 clique가 기본 데이터를 소유하는 특정 CM 인코딩과 연관된다. 포인터와 CM을 고려하면 연관성을 계산하기 어려울 것이다. HAKC는 런타임 동안 접근하는 모든 포인터에 대해 주소 공간 파티션 정보(clique 멤버쉽과 동일)와 구획 정보를 사용하여 후보 CM을 계산함으로써 파티션 접근 정책을 시행한다. 포인터에 접근하기 전에 후보 CM을 포인터의 실제 CM과 비교한다. 런타임 정보로 인해 후보 CM이 실제 CM과 다르면 포인터 역참조는 일어나지 않는다.  
   하드웨어가 주소 공간 파티셔닝과 포인터 CM 연결 primitives를 제공하는 한, HAKC는 정의된 구획화 정책이 준수됨을 보장한다. 만약 구획 내부의 어떤 버그가 포인터를 수정하여 clique나 구획에 대해 정의된 접근 정책을 위반하는 데이터를 가리킨다면, 후보 CM은 포인터의 CM과 다를 것이다. 그런 이유로, 만약 구획 외부의 어떤 버그가 현재 clique를 사용하고 있는 포인터를 접근 위반으로 수정한다면, 후보 CM은 다시 올바른 CM과 다를 것이다. 두 경우 모두 데이터 접근이 차단되며, 구획화된 코드는 명시적으로 부여되지 않은 데이터에 액세스할 수 없다. ARMv8.5-a를 사용하여 HAKC를 구현한 반면, HAKC는 특정 아키텍처에 얽매이지 않는다. 필요한 분할 및 연결 프리미티브를 제공하는 메커니즘은 HAKC을 구현할 수 있다. 
3. Example Case Study
   ![image](https://user-images.githubusercontent.com/73513005/166225521-2569e8f0-e441-41df-896b-92849a24c774.png)  
   여기서, 우리는 앞에서 살펴보았던 Listing 2, 3의 두 LKM을 HAKC이 어떻게 구획화시키는지를 서술할 것이다. 이 예시에서, Listing 2의 모든 코드와 데이터는 구획 1의 black clique에 존재한다.(이를 (1, Black)이라고 명칭한다.), Listing 3의 모든 코드와 데이터는 구획 2의 Gold clique에 있다.(2, Gold).  
   *m2_ioctl*을 실행하면 먼저 런타임 데이터로 계산된 후보 CM과 (2, Gold) CM을 확인하여 *tmp*에 액세스할 수 있는지 확인한다. *m2_ioctl*은 *counts + tmp->idx*에 대한 (2, Gold) CM이 계산된 후보 CM과 일치하는지 여부를 확인하고, *m1_get*이 호출되면 *tmp*를 검정으로 재색칠하고, *tmp*의 값을 (1, Black)과 연관짓는다. *m1_init*가 실행될 때 *m1_counts*를 (1, 검정)과 연결한다. 마지막으로 *m1_get*을 실행하면 *m*과 *m1_counts + m->idx*를 (1, Black)로 확인합니다.  
   공격자가 제어 흐름을 *m2_ioctl*로 지시하는 경우 *ioctl_param*은 (2, Gold)와 적절하게 연결되어야 하며, 이는 계산적으로 수행하기가 어렵다. *m1_get*에 대해서도 유사한 조건을 충족해야 한다. 또한 (1, Black) 외부의 버그가 *m1_get* 값을 구획 외부로 변경하면 포인터가 (1, Black)와 연결되지 않으며 HAKC는 참조를 해제한다.  

## COMPARTMENT POLICY AND ENFORCEMENT MECHANISM IMPLEMENTATION

여기서는 HAKC가 구획화된 코드에 분리를 제공하는 데이터 및 제어 흐름 정책을 시행하는 방법을 자세히 설명한다. HAKC 구획 시행 메커니즘은 태그가 달린 아키텍처(Arm의 MTE)와 암호화 해시(PAC)의 조합을 사용하여 접근 시행을 제공한다. PAC는 포인터가 실수로 변조되지 않았는지, 그리고 포인터가 clique와 구획에 대해 정의된 다양한 접근 제어 정책을 준수하는지 확인하기 위해 사용되는 반면, MTE는 런타임 clique 멤버십을 제공한다.  
구획 식별자 및 접근 제어 정책과 같이 컴파일 시 알려진 정보를 동적으로 수집된 MTE 색상과 결합함으로써 HAKC는 원래 제공된 16개의 구획보다 훨씬 더 많은 구획 세분화를 제공할 수 있다. HAKC는 여러 구획에서 색상을 재활용하지만, 컴파일 시간 정보는 많은 구획을 허용하기 위해 사용 가능한 색상의 "색조"을 효과적으로 생성한다.  
Cliques: Clique는 정확히 하나의 구획에 속하며 코드와 global, 스택 및 동적으로 할당된 데이터를 논리 그룹에 결합합니다. 이 그룹에는 모두 색상($C_c$)이 할당됩니다. $C_c$는 해당 clique가 속한 구획에 고유해야 하지만 전역으로 고유할 필요는 없습니다. 사실, 이 논문의 주요 기여 중 하나는 서로 다른 구획에서 색상을 안전하게 다중화할 수 있도록 하는 설계이다. 클리크가 포함하는 정보의 좋은 예는 내보낸 함수와 정적 함수와 전역 변수, 할당된 객체 스택, 동적으로 할당된 메모리 등 일반적인 C 소스 파일에 정의된 것이다. 그러나 소스 파일의 모든 함수나 데이터가 동일한 Clique에 속하도록 강제하지는 않으며 개발자는 적합하다고 판단되는 대로 자유롭게 분할할 수 있습니다.  
특정 $C_c$를 사용하여 clique들은 포인터 인증과 포인터 서명에 사용되는 $Toc_{acl}$과 $Tok_s$라는 두 개의 토큰을 정의하기도 한다. $Toc_{acl}$은 PAC 인증에 사용되는 컨텍스트를 생성하는 데 사용되며, Clique의 구획 식별자, $ID_n$, 허용되는 Clique 코드 및 데이터 접근을 모두 인코딩합니다. $Tok_s$는 $ID_n$과 $C_c$를 인코딩하고 포인터에 서명할 때 PAC 컨텍스트를 제공합니다. 이러한 토큰이 구획을 강제 적용하는 방법에 대해 추후 자세히 설명합니다.  
Compartments: 구획은 하나 이상의 clique로 구성되지만 사용 가능한 태그 수보다 많은 clique로 구성되지 않으며 전역적으로 고유한 식별자($ID_n$)가 할당됩니다. 모든 clique가 액세스하는 모든 데이터는 구획에 속해야 하며, 이 식별자는 포인터 인증 중에 해당됩니다.  
또한 구획은 간접 점프의 대상이 될 수 있는 clique를 $ID_n$과 함께 인코딩하는 entry 토큰인 $Tok_{ent}$를 정의한다. $Tok_{ent}$는 Clique에서 잠재적으로 코드를 실행할 수 있는 다른 모든 구획에 알려져 있다. 마찬가지로, 구획은 제어 흐름을 이전할 수 있는 모든 유효한 잠재적 구획을 알고 있어야 한다. 따라서, 한 구획은 유효한 구획 $ID_n$과 T∗n의 각 구획의 매핑을 유지한다. 간접 호출을 실행하기 전에, 대상 함수는 유효한 구획에 속하며, T nn의 각 항목 토큰을 사용하여 유효한 항목 Clique인지 점검한다. 그림 4는 허용량과 함께 여러 구획의 예시이다.ble 구획 전환. 이 경우 제어 흐름은 0번 구획에서 1번 또는 4번 구획으로 이동할 수 있지만 3번 구획은 전송할 수 없습니다. 또한 제어 흐름이 구획 0에서 구획 4로 가는 경우 대상 CLIque는 주황색 또는 빨간색이어야 하며 녹색 또는 보라색이 될 수 없습니다. 서로 다른 구획의 파벌들은 서로 다른 접근 제어 정책을 가지고 있지만, 색깔을 공유한다.