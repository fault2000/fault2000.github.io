---
layout: post
title: PUMM, Preventing Use-After-Free Using Execution Unit Partitioning 리뷰
category: [thesis, security]
tags: [thesis, library]
fullview: true
comments: true
use_math: true
author: fault2000
---

# PUMM: Preventing Use-After-Free Using Execution Unit Partitioning

[PUMM: Preventing Use-After-Free Using Execution Unit Partitioning](https://www.usenix.org/system/files/sec23summer_17-yagemann-prepub.pdf)

## 0. Abstract

메모리가 안전하지 않은 언어로 쓰여진 중요한 소프트웨어는 use-after-free와 double free 버그에 취약하다. 이로 인해 메모리 할당기를 보호하기 위해 이러한 버그들이 이용되지 못할 만큼 충분히 오래 메모리 재할당을 전략적으로 미루자는 제안으로 이어졌다. 불행히도, 현존하는 해결책들은 높은 런타임, 메모리 오버헤드에 시달리고 있다. 더 나은 해결책을 찾기 위해, 우리는 각 task(작업)의 처리에 상응하는 코드의 단위를 식별하기 위해 프로그램을 프로파일링하는 것을 제안한다. 런타임 시 분리된 작업 간에 데이터가 거의 또는 전혀 흐르지 않아야 한다는 직감으로, 현재 실행중인 유닛에 의해 free된 메모리의 재할당은 유닛의 완료 후까지 연기되며, 이는 use-after-free 이용을 막기 위할 정도로만 충분히 길면 된다.

우리 설계의 효험을 증명하기 위해, 우리는 C/C++ 바이너리를 보호하기 위해 표준 라이브러리를 투명하게 랩하는 오프라인 프로파일러와 온라인 시행기로 구성된 Linux용 프로토타입인 PUMM을 구현한다. 26개의 프로그램에서의 40개의 현실과 3000개의 인공적인 취약점에 대한 우리의 평가에서, PUMM은 모든 현실 취약점을 성공적으로 좌절시켰으며, 오직 4개의 인공적인 공격을 허용했다. 반면에 메모리 오버헤드를 앞선 연구들에 비해 52%나 감소시켰으며 평균 런타임 오베헤드를 2.04% 발생시킨다.

## 1. Introduction

C와 C++ 같은 메모리가 안전하지 않은 언어들은 만연하며 공격자들이 보통 이용하는 바이너리 수준의 버그들을 찾아내기 까다롭게 구성되어있다. 가장 일반적이고 발견하기 까다로운 종류들 중 하나는 use-after-free로, 프로그램이 동적으로 할당된 메모리를 free할 때 발생하며 나중에 dangling 포인터를 사용하여 안전하지 않은 메모리 접근을 야기한다. 이는 또다른 일반적인 종류인 이미 free된 버퍼에 두 번째 free를 호출하는 위반 사용을 가리키는 double free를 포함한다. 가장 온화한 경우에, UAF는 프로그램 충돌과 denial of service(DoS)를 야기한다, 하지만 더 자주 인공적인 코드 실행을 가능하게하며, 공격자가 프로그램의 완전한 제어를 가져갈 수 있게 한다. 2020에만 NIST는 Google Chrome에 73개, Mozilla Firefox에 17개의 UAF 경보를 발표했다. 몇 가지 예를 들자면 UAF는 Chrome, Adove Reader, Windows 10에 임의의 코드 실행을 가능하게 한다.

UAF가 DoS를 유발하여 임의 코드 실행을 가능하게 하는 근본적인 요인은 새롭게 free된 주소 공간에 재할당되는 데이터를 제어할 수 있는 공격자의 능력이다. 예를 들어, 만약 코드 포인터를 담고 있는 메모리가 free되고 재할당된 뒤 공격자에 의해 선택된 내용이 담긴 버퍼가 덮어쓰여진다면, UAF를 발생시키는 것은 프로그램이 이 버퍼를 마치 여전히 원래 코드 포인터처럼 참조하는 것을 초래할 것이며, 프로그램 카운터(PC)를 공격자가 선택한 주소로 보낼 것이다.

그에 대응하여, 연구자들은 악용을 막기에 충분히 길게 재할당을 미루는 메모리 할당기를 재설계할 것을 제안한다. 만약 공격자들이 앞선 메모리 객체를 새로운 객체로 덮어쓸 수 없다면(이전 예시처럼), UAF를 통한 코드 실행은 더 이상 불가능할 것이다. 보여지는 해결책은 적은 오버헤드를 요구하고, 표준 관리 라이브러리(예: libc)를 대체하고 바이너리 전용 설정(소스 코드 또는 디버그 기호에 접근하지 않고)에서 작동하여 상용 기성품(COTS) 및 레거시 소프트웨어에 대한 보호를 개선할 수 있습니다.

최근 몇 년 동안, 이 문제를 해결하기 위해 2가지 전략이 제시되었다. 각각 scanning과 one-time allocation(OTA)이다. scanning 접근에서, free된 주소는 메모리 검사가 어떤 가능한 포인터도 남아있지 않음을 확인할 때까지 격리되며, 그 시점에서 포인터가 재할당을 위해 풀려난다. 개념적으로, scanning은 프로그램 바이너리에 garbage collection을 새로 추가하는 것과 비슷하다. 역으로, OTA 접근은 프로그램 생명 주기 동안 할당된 주소가 절대 재할당되어지지 않게 시행한다.

두 접근은 직관적인 보안 보장을 제공한다. 하지만 그들은 여전히 실용적이고 근본적인 제한에 시달린다. Scanning은 포인터를 난독화 하는 코드(예를 들어, 포인터를 flag 혹은 참조 카운터와 결합)에서는 작동하지 않으며 false positive 감지로 인해 메모리를 과도하게 격리할 수 있다. 역으로, OTA는 재할당이 허가되지 않기에 프로그램의 가상 주소 공간을 결과적으로 고갈될 것이다. 두 경우, 현재 최상의 소프트웨어를 사용한 구현은 최악의 경우 실행과 메모리 오버헤드를 각각 50%~100%를 초래한다.

더 나은 해결책을 찾기 위해, 우리는 우리의 관심을 또다른 연구 영역으로 돌렸다, **data provenance**(데이터 출처)로 겉보기에 직교하는 문제인 false provenance(거짓 출처)를 해결하는데 수년을 들인 문제이다.(false dependency explosion라고도 알려진). 여기, 연구자들은 공격 탐지 및 법의학 조사를 용이하게 하기 위해 시스템 이벤트 로그(시스템 호출, 애플리케이션 로그 메시지)를 기반으로 대상(클라이언트, 파일 등)을 객체(클라이언트, 파일 등)에 인과적으로 연결하는 것을 목표로 한다. 하지만, 그들은 길게 실행되는 프로그램이 가짜 의존성을 발생시킨다는 사실을 빠르게 알아내었고, 이로써 어떤 개체가 그 프로그램이 접촉한 모든 이전 개체와 인과적으로 관련이 있다고 잘못 판단되었다. 이것을 다루기 위해, 연구자들은 종속성을 분할하기 위해 프로그램을 자율적인 작업 단위로 분할하는 execution unit partitioning(EUP)라 불리는 기술을 정제했다. 예를 들어, HTTP 서버의 단위는 하나의 요청을 처리하는 코드로 구성되며, 서버가 종료될 때까지 이 코드를 반복한다.  

 EUP가 흥미로운 이유는 유닛의 후속 반복이 이전 반복에 대한 데이터 의존성이 없다는 특별한 속성을 유닛이 가지기 때문에 이것이 작동한다는 점이다. 따라서 관련 이벤트를 정리하지 않고도 유래를 정확하게 분할할 수 있다. 이 관찰에 따르면, 우리는 실행 유닛이 free된 메모리가 재할당되기에 안전할 때를 알려주는 효과적인 가이드 역할을 할 수 있다는 가설을 만들어낼 수 있다. 예를 들어, HTTP 서버가 다음 요청으로 넘어가면, 비록 일부가 메모리에 dangling 상태로 남아 있고, 새로 할당된 데이터가 초기화되어 이전 값을 안전하게 덮어쓰더라도 이전 요청의 포인터에 접근할 가능성은 거의 없다. 이것이 모든 경우에 유지된다고 보장할 수 없는 [휴리스틱](https://ko.wikipedia.org/wiki/%ED%9C%B4%EB%A6%AC%EC%8A%A4%ED%8B%B1_%EC%9D%B4%EB%A1%A0)이지만, 이것의 경험적 견고성은 10년간의 공식 연구에서 입증되었다.  

 개념적으로, 우리의 아이디어는 전역이 아닌 실행 단위의 세분화에서 OTA를 실행하는 것으로 생각할 수 있다. 유닛이 오프라인에서 식별되어질 수 있기 때문에, 그들에 기반을 둔 정책은 CPU-집중적인 스캐닝을 필요로 하지 않고 런타임에 효율적으로 실행가능하다. 격리된 주소들은 각 새 반복의 시작에서 풀려나는 것이 보장되어지기 때문에, 주소 공간은 전역 OTA에서 처럼 허비되어지지 않을 것이다. 요컨대, 우리의 전략은 스캐닝의 성능 오버헤드와 OTA의 메모리 오버헤드 둘 다를 피하는 것이다.  

 하지만, 이 아이디어를 작업 설계로 변환하는 것은 사소한 작업이 아니다. 우리가 극복해야 하는 첫 번째 도전은 제거되고 소스 코드가 부족한 임의의 프로그램에서 지연된 재할당을 알려주는 적절한 유닛을 식별하는 방법이다. 이를 위해, 우리는 데이터 출처 커뮤니티에 의해 검증되고 신뢰받는 공통 패턴인 실행 유닛을 나타내는 외부 루프를 감지하기 위해 오프라인 동적 프로파일링에 기반한 기술을 제안한다. 우리의 연구는 Perf 같이 발달된 프레임워크에 의해 제공되는 동적 계측(예를 들어, DynamoRIO) 혹은 하드웨어 processor tracing(PT)과 호환되어 현대 장치 전반에 걸쳐 광범위한 호환성을 달성한다.  

 audit log(검사 로그) 대신 low-level 런타임 행동을 사용하여 유닛을 감지하는 것은 이전 작업처럼 시스템 호출과 애플리케이션 메세지를 분할하는 것보다 메모리를 관리하는 우리의 목표를 반영하는 독특한 차이점이다. 그 결과, EUP는 좋은 시작 영감을 주는 반면, 우리가 제안하는 알고리즘은 식별되는 유닛의 세분성에서 특별하며 이전 EUP 작업의 직접적인 이식이 아니다.

 다음으로, 우리는 식별된 유닛을 메모리 할당기를 위한 효율적인 실행가능한 격리 정책으로 전환하기 위해 우리의 주의을 돌렸다. 이를 위해, 우리는 프로그램 속 어떤 계측 혹은 PT를 필요로 하지 않고 런타임에 정확하게 식별할 수 있는 release point(방출점)의 위치를 찾는 알고리즘을 제안한다. 특히, 우리의 설계는 프로파일링된 trace의 control flow를 분석하여 알려진 실행 유닛의 시작에서 발생하는 메모리 관리자의 function에 대한 caller를 식별한다. 이 caller는 스택에 푸쉬되는 return 포인터에 의해 런타임 때 쉽게 식별할 수 있으므로 장치의 새로운 반복이 시작될 때마다 이전 격리된 주소를 안전하게 해제할 수 있다.

## 2. Overview

### 2.1 Motivating Example

 PUMM이 어떻게 철저히 설명하기 위해, Figure 1에 표시된 예제를 참고한다. Figure 1은 명확성을 위해 소스 코드로 표시된다(PUMM의 실제 분석에는 프로그램 바이너리만 필요함). 간략함을 위해, 우리는 프로그램의 파일 파싱 루트만으로 예시를 줄였다.

![https://user-images.githubusercontent.com/73513005/201514026-f189ff91-a839-44ef-86f1-41bb35f64798.png](https://user-images.githubusercontent.com/73513005/201514026-f189ff91-a839-44ef-86f1-41bb35f64798.png)

 이 예시에서, 함수 getline이 가져와지고 가변 길이 line을 저장하기 위한 버퍼를 동적으로 재할당하기 위해 line 16에서 realloc을 호출한다. 그런 다음 루틴이 포인터로 리턴된다. 불행히도, line 10은 getline에 의해 리턴되는 값을 정확히 검사하지 않기에 UAF 취약점을 허용하며, 이는 line 11이 dangling 포인터를 parse 함수에 넘겨줄 수 있음을 의미한다.  

 PUMM이 어떻게 이 버그가 이용당하는 것을 방지할까?(논문에서 물음표를?) 첫째로, 오프라인 상태 동안, PUMM은 테스트 입력의 실행 trace를 수집하기 위해 프로그램을 프로파일하여 보여지는 control flow graph(CFG)를 밝힌다. 이 경우, PUMM은 4개의 단순한 사이클(기본적인 순환)을 감지하고 주황색 사이클(Node 10)의 맨 앞이 다른 사이클들의 선두를 지배하기 때문에, 보라색으로 보여지는 것처럼 하나의 실행 유닛으로 합쳐질 수 있다. 유닛의 선두(Node 10)가 코드의 가장 바깥쪽의 루프이기도 함을 명심하자. 이는 우연이 아니며, 3.2 하위 구역에서 자세히 언급될 것이다. 하지만 지금은, 결과 유닛이 line 10의 while 조건에 해당하는 1개의 입구/출구 노드를 가짐을 관찰한다. 또한 getline에 의해 동적으로 메모리에 할당된 모든 포인터가 반복의 시작에서 초기화되고 하위 구역 반복에서 절대로 접근되지 않음을 기억하자. 이는 우리가 식별한 유닛이 하나의 입력(즉, 하나의 파일 라인)을 자율적으로 처리하기 위한 모든 코드를 포함하고 있기 때문에 이는 타당하다.  

 모든 식별된 유닛과 함께, PUMM은 다음으로 모든 caller에 메모리 관리자 함수를 할당하고 유닛에 속하는 것이 있는지 확인한다. 이 예시에서, 유닛의 선두 근처에 realloc 호출이 있다. 이 호출에 도달한다는 것은 유닛의 새로운 반복을 가리키며, 한번 도달하면, 이전 반복으로부터의 데이터에는 접근할 수 없음을 명심하자. 결과적으로, 이전 반복의 모든 dangling 포인터는 다시 쓰이지 않은 채 메모리에 남겨져 UAF 위험을 제기하지 않을 것이다. PUMM은 realloc의 caller를 격리된 주소를 풀어주는 안전한 caller로 보안 프로파일에 기록한다.  

 실행 시간 동안, PUMM의 메모리 관리 wrapper는 OS에 의해 로드되고 링크된다. 리눅스를 위해, 이는 ld의 설정에서 설정되거나 LD_PRELOAD 환경 변수로 수행될 수 있다. 두 케이스 모두, PUMM의 wrapper는 프로그램에 보안 프로파일이 있음을 감지하고 그것을 로드한다. getline이 realloc을 호출할 때마다, 호출로 인해 free된 메모리는 격리되어지고 이전에 격리된 메모리는 재할당을 위해 풀려난다. 이 정책 하에, crash를 일으키기 위한 UAF 버그는 여전히 가능함을 기억하자. 하지만, 적절하지 않게 접근된 메모리는 격리되기 때문에, UAF는 오직 원래 free된 데이터에만 접근 가능하기에 공격자가 악용할 수 없게 만든다. 하위 영역 2.2에서 UAF 악용의 분류를 자세히 설명하고 2.3에서 위협 모델에 대해 정의한다.  

### 2.2 Use-After-Free Explotiation

 프로그램 내의 UAF 버그를 가지는 것에 대한 결과는 접근된 메모리의 상태에 따라 상당히 달라지며 이는 Table 1에서 요약되었다.

![https://user-images.githubusercontent.com/73513005/201518600-d02a32ee-65df-4a11-9154-0c23e6bc84e2.png](https://user-images.githubusercontent.com/73513005/201518600-d02a32ee-65df-4a11-9154-0c23e6bc84e2.png)

가장 온화한 케이스(L1)에서, 메모리에 남겨진 dangling 포인터는 이미 언매핑되거나 풀려나 더이상 프로그램에 접근할 수 없게 만들어진 주소를 참조한다. 이는 충돌을 일으킬 수 있거나, UAF를 반복적으로 발생시켜 DoS 시나리오를 만들 수도 있지만, 프로그램의 실행을 제어하기 위해 악용되어질 수는 없다.  

 L2에서, 포인터에 의해 참조되어지는 free된 메모리는 여전히 접근가능하지만, 재할당되어지지는 않았기에, free되어지기 전 기존 데이터를 여전히 포함하고 있다. 그래서 프로그램 논리에 따라 충돌을 일으키거나 관찰할 수 있는 이상 현상이 발생하지 않을 수 있으며 보안 할당자의 경우 L1보다 더 악용가능하지 않다. 역으로, 메타데이터로 free된 메모리를 덮어쓰는 할당자의 경우, 이는 공격을 성취할 수도 있으나, 하지만 이는 가능성이 낮으며 메모리 관리자의 코드에서 메타데이터가 저장되는 곳을 변경함으로써 회피되어질 수 있다.  

 L3와 L4부터 UAF가 심각한 위협이 된다. 이 경우, free된 메모리가 재할당되어지면서오래된 데이터가 새로운 데이터로 덮어쓰여지는 것을 야기한다. 만약 오래된 코드 포인터 혹은 control-dependent 변수가 덮어쓰여진다면, UAF는 프로그램 실행을 다른 방향으로 보내어 공격을 달성할 수 있다. 새 데이터가 공격자에게 조종되어지지 않는 상황에서(L3), 성공 여부는 프로그램이 이전 데이터가 공격자에게 이득이 되는 값으로 덮어쓰여질 확률에 결정된다. 역으로, 만약 공격자가 어떤 새 값이 쓰여지는지 조종할 수 있다면(L4), 임의의 코드 실행을 달성할 수 있다.  

### 2.3 Threat Model

 이전 연구와 비슷하게, 우리의 목표는 UAF를 악용가능하게 되는 것을 방지하는 것이다. 이것은 공격자가 UAF 버그를 발생시켜 프로그램이 나타내는 동작을 조종할 수 없어야 한다(예를 들어, 하위영역 2.2의 L3와 L4를 방지). 이 정의에 의하면, 할당자가 free된 메모리에 메타데이터를 저장하지 않는다고 가정할 때, UAF에 의한 충돌(L1) 혹은 이전 데이터 접근과 지속(L2)는 시스템에 어떤 해도 끼치지 않기에 이를 만족한다. 하지만, 완전성을 위해, 충돌이 여전히 DoS를 일으킬 수 있기 때문에 우리의 평가에 이 결과들을 구별할 것이다.

 우리는 대상이 되는 프로그램이 노출되지 않은 상태에서 시작된다고 가정하며, 공격자가 바이너리 공격을 시작할 욕구를 자극한다. 공격자는 목표 프로그램이 어떻게 작동하는지, 어떤 UAF 버그를 가지고 있는지에 대한 모든 지식을 가지고 있다. 이는 임의 읽기 및 데이터 유출을 발생시켜 기밀(예를 들어, 스택 카나리, ASLR 오프셋)을 노출시켜 작업 악용에 도움을 줄 수 있는 기능이 포함된다. 우리의 정책은 로드된 라이브러리를 사용해 런타임동안 실행되기 때문에, 공격자 또한 읽을 수 있다. 하지만, 우리는 공격자가 임의 쓰기 능력은 가지지 못했다고 가정한다, 그렇지 않으면 공격자는 공격을 달성하기 위해 free된 데이터를 격리된 동안 재작성할 수 있다. 비슷하게, 우리는 공격자가 임의로 새 프로그램 경로를 만들어낼 수 있다고 고려하지 않는다. 이 한계는 모든 이전 연구에 적용되며 임의 쓰기와 control flow 장악이 더 강한 능력이기 때문에 타당하다. 다시 말해, 만약 공격자가 이들 중 어느 하나라도 이미 가지고 있다면, 그들은 이미 실행의 경로를 바꿀 수 있기에 UAF를 악용할 필요가 없다.  

 우리는 대상이 되는 시스템의 커널이 노출되지 않았다고 가정한다. 왜냐하면 우리는 우리의 실행 코드를 로드하는 것을 그것에 의존하기 때문이며 이전 연구들도 그러하다. 만약 공격자가 이미 커널을 조종한다면, 그들은 시스템을 조종할 수 있고 이는 유저의 프로그램 버그를 이용할 필요가 없기 때문에 이는 현실적이다. 우리는 또한 보안 프로파일이 안전하게 저장되고 실제로 파일 사용 권한을 사용하여 얻을 수 있는 라이브러리에 의해 안전하게 로드됨을 가정한다.

## 3. Design

 PUMM은 Figure 2에서 보여지는 것처럼 메모리 관리 wrapper를 사용해 runtime 동안 실행되는 보안 프로파일을 생성하는 오프라인 바이너리 분석 페이즈로 구성되어 있다.  

![https://user-images.githubusercontent.com/73513005/202486237-c8776872-e1e4-4458-8c21-6df7b75a0384.png](https://user-images.githubusercontent.com/73513005/202486237-c8776872-e1e4-4458-8c21-6df7b75a0384.png)

 오프라인 페이즈를 위한 프로파일링은 동적 바이너리 계측 혹은 PT를 통해 촉진될 수 있다. 간결성을 위해, 우리는 오직 Linux Perf와 Intel PT를 사용한 것만을 기술하지만, 계측 코드는 정확히 같은 기능을 에뮬레이트할 수 있다는 것을 염두해야 한다.  

 먼저, PUMM은 테스트 입력을 처리하는 프로그램의 실행 trace를 기록하고 CFG(subsection 3.1)로 디코딩한다. 그 다음 PUMM은 이 CFG를 바이너리 코드 속의 실행 유닛을 판별하는 분석을 실행하기 위해 사용한다(Subsection 3.2). 마지막으로, PUMM은 재할당을 위해 격리된 메모리 주소가 안전하게 풀려날 수 있는 프로그램 속 장소를 식별하여 런타임 wrapper를 위한 보안 정책을 제공한다.(3.3)  

### 3.1 Dynamic Profiling

 PUMM이 보안 정책을 생성할 수 있기 전, 먼저 목표 프로그램에 어떤 실행 경로가 있는지 알 필요성이 있다. 우리는 기존과 COTS 프로그램을 지원하는 소스 코드가 없는 케이스를 다룰 필요가 있기 때문에, PUMM은 LLVM이 제공하는 것과 같은 정확한 컴파일러 기반 접근에 의존할 수 없다. 역으로, 정적 바이너리 분석은 특히나 애매한 프로그램에서 실행하기 어렵고, 크고 복잡한 코드에 맞춰져 있지 않다. 대신, PUMM은 목표 프로그램의 실행 trace를 기록하는 동적 프로파일링에 의존한다. 이 연구의 목적을 위해, 우리는 개발자 테스트 사례가 포함된 fuzzer를 사용하여 프로파일링 단계를 주도하기 위한 입력을 수집한다. 코드 적용 범위의 효과는 평가에서 측정된다.  

 **Processor Tracing** PUMM의 프로토타입은 skylake 프로세서에서 처음으로 소개된 하드웨어 기능인 Intel PT와 실행 trace를 기록하기 위한 Perf를 활용한다. Perf의 trace 데이터로부터, PUMM은 다중 스레드와 동적으로 생성된 코드가 포함된 복잡한 시나리오에서도 프로그램이 실행한 각 명령을 복구할 수 있다.  

 Figure 3는 복구 프로세스의 예시를 보여준다.

![https://user-images.githubusercontent.com/73513005/202486091-45799965-ffc9-4854-8cd2-cd21648db5f5.png](https://user-images.githubusercontent.com/73513005/202486091-45799965-ffc9-4854-8cd2-cd21648db5f5.png)

 왼쪽이 Intel PT 패킷(파랑색)과 Perf sideband(측파대) 패킷(grey)의 흐름을 인코딩한 기록된 trace이다. 간략화를 위해, 그림은 각 패킷이 가진 모든 데이터(CPU 타임스탬프)를 보여주지 않는다. 첫 패킷은 PUMM에게 목표 스레드(PID 1234)가 프로세서 코어에서 실행되기 시작했음을 알려준다. 이어서 스토리지에서 메모리로 객체가 로드되었음을 PUMM에게 알리는 mmap 이벤트가 발생한다. 이 값은 어떤 객체인지와 기본 가상 주소를 기록하여 PUMM이 디스어셈블러 내에서 동일한 메모리 레이아웃을 재창조할 수 있도록 한다. 다음 패킷은 PT 데이터를 가지므로, PUMM이 분기(jle)에 도달할 동안 선형 디스어셈블링 명령(linear disassembling instruction)을 재개할 수 있도록 한다. 그 후 PUMM은 분기가 넘어갔다는 PT 패킷을 찾아내어, PUMM이 적절한 목표 주소(0x2850)에 점프한 후 재개된다. 다음 분기(jne) 때, 다음 PT 패킷은 not-taken을 기록하므로, PUMM은 다음 명령(0x2883)으로 실행되지 못한다. 다음 패킷은 또다른 mmap 이벤트이므로, PUMM은 특정한 객체를 불러온다. 0x288f의 간접적 호출에 닿으면, 다음 PT 패킷은 디스어셈블러를 0xfeff로 보내는 목표 IP(TIP)를 가진다. 이 절차를 계속하면, PUMM은 실행된 모든 명령을 복구한다.  

 주소 공간 레이아웃 무작위화(ASLR) 때문에, 명령의 가상 주소는 각 실행마다 변경된다는 점을 주목하자. 이를 다루기 위해, PUMM은 절대 가상 주소를 객체 기반과 연관된 오프셋으로 변환한다. 이를 통해 trace를 하나의 통합된 그래프로 합치는 PUMM의 분석의 후반 단계를 진행할 수 있다.  

 **Control Flow Graph Construction**  일단 PUMM이 trace에서 실행한 명령을 복구하면, 이 정보를 CFG로 증류(distill)한다. 하지만, PT에서 CFG를 생산하는 것은 평범한 과제가 아닌데, 왜냐하면 trace는 하드웨어 이벤트로 인한 갑작스러운 interrupt와 다른 low level artifacts같은 구멍을 포함할 수 있기 때문이다. 이는 제거되야할 뿐만 아니라, 3.2에서 설명된 실행 유닛 분할에 도움이 되는 추가 메타데이터도 복구되어야 한다.  

 알고리즘 1은 이 문제를 극복하기 위해 PUMM이 사용한 과정을 보여준다. 이는 명령 I의 선형 순서로 시작하며, trace를 나타내는 vertices(꼭짓점) V와 edge tuples E의 리스트를 생성한다. 생성된 CFG는 분기, 간접 호출, 간접 점프 또는 return 명령으로 끝나는 명령의 선형 시퀀스로 정의하는 바이너리 코드 블럭에 기반되어진다. 이 블럭들은 하나의 입구, 하나의 출구 순서를 가지며 이는 메모리에서 겹쳐질 수 있다.  

 알고리즘은 추적된 각 명령에 대해 반복해서 작동한다. line 10에서, 알고리즘은 현재 블록 안에 있는지 아닌지를 확인하고, 현재 명령의 주소를 새 블록의 시작으로 기록한다. Line 13은 이전에 정의된 것처럼 현재 명령이 출구인지 확인한다. 만약 그렇다면, 이 명령은 현재 블록의 끝으로 표시된다. Line 14-16은 새 노드 n을 생성하며, vertices V의 리스트에 추가하고, E의 이전 노드에서 edge를 생성한다. V와 E는 만약 trace 속에서 같은 전송이 여러번 발생하면 중복된 입구를 포함할 수 있다. 우리는 3.2에서 이들이 어떻게 병합되는지 기술한다.  

 n에 대한 이전 블럭이 없을 때, 어떤 edge도 CFG 내에서 생성되지 않는다. 이는 trace 시작 지점 첫 블럭에서 나타나며, line 3-9에서 처리한 것처럼 PT가 꺼지는 경우도 있다. PT가 오직 유저 공간만 추적하도록 설정되어서 발생한 시스템 호출로 인해 멈췄을 때, 알고리즘 1은 결과로 초래된 edge들을 가지고 있는다. 그렇지 않으면, 중단는 exception 혹은 context switch일 수 있는 interrupt의 결과이다. PUMM이 실행이 interrupt된 문맥에서부터 재개될지 확신할 수 없기 때문에, 알고리즘 1은 보수적으로 동작하며 edge를 생성하지 않고 대신 구멍을 채우기 위해 후속 trace에 걸친 중복성에 의존한다.  

 시작과 끝 주소에 더해, 각 블럭은 현재 블럭으로 이끄는 모든 caller를 추적하는 caller context 리스트 c로 이름붙여진다. 이는 본질적으로 3.2와 연관될 수 있는 line 20-25에 의해 관리되는 쉐도우 스택이다.  

### 3.2 Execution Unit Partitioning

 PUMM의 분할의 키는 여러 작업(네트워크 요청, 입력 파일 등)을 실행할 수 있는 프로그램이 보통 종료 조건 혹은 signal 발생까지 각 작업마다 한번 반복되는 주 작업 루프로 구현되어지는 것이다. 로컬 변수는 작업의 시작에 초기화되어지며 현재 작업은 이전 작업의 데이터에 의존하지 않는다.  

 PUMM의 주요 과제은 주 작업 루프 자체가 분기되는 경로에 의해 연결되는 루프를 포함하고 있다는 것이다. 우연히 내부 루프 중 하나를 그것의 실행 유닛으로 식별하는 것(과소 평가)은 격리된 메모리의 너무 이른 해제를 불러올 것이며, 반면 과대 평가는 유닛의 추가적인 불필요한 메모리 오버헤드를 발생시킨다.  

 이 과제를 해결하기 위해, PUMM은 먼저 3.1의 CFG를 후처리하여 상황에 민감한 노드를 생성하고 바이너리 객체(예: 라이브러리)에 걸쳐 호출에 대한 가짜 리턴을 삽입한다. 전자가 라이브러리 주변의 wrapper를 처리하여 더 정확한 분석을 내며 후자는 PUMM이 모든 객체 간 경로를 순회하지 않고도 객체 별 프로그램을 분석할 수 있게 한다.

 다음으로, PUMM은 Hawick 회로 계산 알고리즘을 사용해 간단한 회로(예: 루프)를 식별하며, 이 알고리즘은 다음과 같은 최악의 경우 시간 복잡도를 가진다.

$$
O[(V+E)(C+1)]
$$

 V는 vertice의 수, E는 edge의 수, C는 회로의 수이다. 회로가 자리잡은 상태에서, PUMM은 이들을 병합하여 그래프 우위를 기반으로 실행 유닛을 만들어내기 시작한다. 자세히는, 주어진 회로 A와 B에서, 만약 A의 선두(예: entry node)가 B의 선두의 우위에 있다면 B는 A와 병합된다. 이 실행은 병합할 수 있는 유닛이 더 이상 없을 때까지 반복된다.

### Policy Generation & Enforcement

 실행 유닛이 식별된 상태에서, PUMM은 목표 프로그램을 위한 보안 정책을 생성해낼 수 있다. 이 단계를 위한 목표는 프로그램 내의 재할당을 가능하게 하는 격리된 메모리가 안전하게 풀려날 수 있는 지점을 식별하는 것이다. PUMM이 극복해야하는 주 과제는 정책이 계측 혹은 PT를 요구하지 않고 런타임 동안 실행가능해야 한다는 것이다. 이는 목표 프로그램을 실행하는 시스템이 PT 하드웨어를 가지지 않을 수 있다는 점과 소스 코드 없이는 계측이 동적으로 삽입되어져야 하며 이는 높은 성능 오버헤드를 발생시킨다.

 우리의 해결책은 대부분의 실행 유닛이 동적으로 할당된 변수를 포함한 변수 초기화와 함께 시작한다는 관찰에서 기인했다. 새 변수를 할당하기 위한 기본 메모리 관리 라이브러리를 호출하는 코드 블록은 스택 되감기를 필요로 하지 않고 스택에 푸쉬된 마지막 리턴 주소를 식별할 수 있다. 이러한 호출은 새 유닛 반복의 시작에서 발생하기 때문에, 이전 반복에서 격리된 메모리는 적은 위험을 가지고 풀려날 수 있으며 section 4에서 실증적으로 평가된다.

이 아이디어를 염두에 두고, PUMM은 PUMM에 의해 감싸진 메모리 할당 함수에 대한 unit 내의 모든 caller들을 식별하는 것으로 시작한다. 각 caller에 대해, PUMM은 unit 반복에서 첫 caller가 될 수 있는지 확인한다. 예를 들어, caller가 또다른 caller를 거치지 않고 unit의 선두에 도달할 수 있는지이다. 만약 그렇다면, caller는 정책에 격리 리스트를 위한 해제 지점으로 추가된다.

 실행 시간동안, OS는 동적으로 PUMM의 메모리 관리 wrapper를 로드하며, 현재 프로토타입에서는 모든 POSIX 메모리 관리 기능(예: malloc, free)을 다룬다. 그러면 정책이 차례로 로드되고 보호된 함수를 호출할 때마다 정책이 적용된다. 버퍼 해제가 필요한 요청으로 격리 목록에서 해제된 주소 공간을 대기열에 넣어 재할당할 수 없다. 각 호출마다, caller는 스택에 푸쉬된 리턴 주소에 기반하여 식별되며 만약 정책의 안전한 caller 리스트에 있다면, 격리된 리스트는 풀려나며, 이러한 주소 공간들을 재할당이 가능하게 만든다.

 이 설계와 함께 우리가 만든 흥미로운 발견은 free가 격리 리스트로 인해 미루어지기 때문에, abort를 가지는 일 없이 double free 버그를 자동적으로 해결하는 것이 가능했다는 것이다. PUMM에서, 만약 격리 도중 두 free가 존재하면, 하나의 해제로 간단히 병합될 수 있으며, 이는 위반을 해결한다. 하지만, 몇몇 시스템 관리자는 double free의 중단을 원할 수 있으며 이는 PUMM이 하도록 설정할 수 있다. 우리는 section 5에서 절충점을 설명한다.

## 요약

 이 논문은 Linux Perf와 Intel PT를 활용해 오프라인에서 각 프로그램의 모든 유닛을 식별하고 이를 이용해 한 유닛에서 사용되고 free된 객체의 주소를 격리시켜 두다가 유닛이 끝나면 풀어주는 방식으로 use-after-free 버그를 막으려는 시도를 담고 있다. 기본적으로 프로그램이 다중 실행되어질 때, 한 주요 루프가 있고 이를 반복해서 실행하여 프로그램이 작동하는데, 이전 반복에서 free된 객체는 현재 반복에서 재사용되더라도 피해를 끼칠 수 없는 경우가 대부분이라는 발상하에 각 루프를 유닛으로 구분하고 유닛의 끝마다 격리된 주소를 해제하는 방식으로 작동하는 것이 주 요지이다.

 문제는 PUMM이 프로그램을 분석하는데 평균 12시간이 걸린다는 것. 이게 평균적인 시간인지는 모르겠다. 논문에 안나와서. 그래도 비교대상인 MarkUs와 FFmalloc에 비해 낮은 평균 런타임, 메모리 오버헤드를 가진다. 생각보다 유의미한 차이가 나오니 궁금하면 논문 찾아가라. 그런데 아무래도 12시간 걸리는거 생각하면 프로그램에 패치나 업데이트가 있을 때마다 12시간 동안 검사 돌린다고 생각하면 살짝 어질어질하다. 이 부분은 확실히 보완이 필요해보인다.