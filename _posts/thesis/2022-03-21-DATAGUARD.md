---
layout: post
title: The Taming of the Stack:Isolating Stack Data from Memory Errors 리뷰
category: [thesis, security]
tags: [thesis, LLVM, stack]
fullview: true
comments: true
use_math: true
author: fault2000
---

## INTRODUCTION

스택 메모리 공격은 아직도 주 위협으로 남아 있으며, 이는 스택 오버플로수 취약점이 흔한 상태로 남아 있고, 새 약점들이 발견되고 있기 때문이다.

1. 메모리 오류 테스팅의 발전에도 불구하고, 스택 오버플로우 취약점을 제거하지 못한다.
2. 공격자는 메모리 에러를 효과적으로 활용할 수 있는 다른 방법을 찾아낸다.

이러한 상황에 더해, 현재 방어 방법들은 스택 메모리 에러를 제한된 범위 혹은 배치에 비싼 비용을 요구한다.  
안전한 스택 객체를 효율적으로 효과적으로 보호하기 위해 식별하는 것은 몇 가지 도전이 따른다.  

1. 안전한 스택 객체가 메모리 에러로부터 완전히 안전하는 것을 보장
2. 메모리 에러로부터 보호되는 스택 객체의 수를 정적으로 늘리는 것
3. 안전 보장이 안전하지 않는 객체를 안전하다고 잘못 분류하지 않는 것

이 논문은 DATAGUARD를 소개한다.

이 논문은 다음과 같은 공헌을 하고 있다.

* 공간적, 유형적, 시간적 메모리 오류와 관련하여 안전하지 않은 스택 개체가 안전하다고 분류되지 않도록 하며 가능한 한 많은 스택 개체를 "안전"하다고 마킹하는 목표를 달성했다.
* 공간적, 유형적, 시간적 메모리 오류에 대한 스택 객체의 안정성을 검증하여 스택 객체의 보호 범위를 증가시키는 훨씬 더 정확한 방법인 DATAGUARD를 제안한다.
* 새로운 스택 객체 안전성 제약 모음을 제공하고 정적 분석과 기호 실행을 결합하여 입증된 안전 스택 객체의 수를 최대화하는 세 가지 종류의 메모리 오류를 검사하는 안전 분석을 개발하여 clang의 safe stack에 의해 안전하지 않다고 판명된 스택 객체의 65% 이상의 안전성을 검증했다.
* DATAGUARD가 Safe Stack이 잘못 분류한 스택 객체의 6.3%를 삭제함으로써 Safe stack 객체의 보안을 향상하고, SPEC CPU2006 16개의 벤치에서 4.3%의 성능 오버헤드만으로 스택 메모리 에러의 악용을 방지한다.

## MOTIVATION

### 예제

![image](https://user-images.githubusercontent.com/73513005/159540476-6ee7b968-052c-4a69-ac12-ac670da8c830.png)

위 그림은 세 종류의 메모리 에러의 예시를 보여주며, ct가 공격자에 의해 조작될 수 있다고 가정하자.  
먼저 line4는 공간적 에러다. ct가 실제 buf의 크기보다 크거나, buf의 크기가 정의된 BUF_SIZE보다 작을 수 있기에 공간 오류가 발생한다.  
line5는 유형적 오류이다. ct가 int로, 음수가 될 수 있으나, size_t는 unsigned이므로 음수가 될 수 없다. 이는 버퍼 오버플로우 같은 범위 에러를 유발한다.  
line7은 시간적 오류이다. buf는 example이 반환된 후에도 사용될 수 있다. 그러나 lbuf는 로컬 함수이므로 line7의 메모리 주소 레퍼런스를 lbuf로 선언하는 것은 로컬 함수의 범위를 벗어나 사용될 수 있음을 암시한다. 즉, 댕글링 포인터를 만들어낸다.

### 현재 방어 기법

아무튼 제한된 기법은 이제 안통한다는 소리

### Safe Stack 배경

이 논문은 아무래도 clang에 적용되어 있는 safe stack과의 비교를 주안점으로 두고 있으므로 관련된 이해가 필수적으로 필요하다.  
Safe Stack은 안전/안전하지 않은 스택을 분별하는 정적 분석 패스와 각 스택에 올려져 있는 스택 객체를 위치시키거나 참조하는 계측 패스, 안전한 스택의 무결성을 보장하기 위한 런타임 지원들로 이루어져 있다. 정적 분석 패스는 객체가 단일 스택 프레임 내의 스택포인터로부터 일정한 오프셋(컴파일러에 의해 결정된)만을 사용하여 접근되는 경우 객체를 안전한 것으로 분류한다.  
리턴 주소 같은 코드 포인터들은 이 조건을 자주 만족하는 반면, 몇몇 스택 데이터 객체와 데이터 포인터들은 이를 준수할 수도 있다. 계측 패스는 두 분리된 스택을 만들어 안전한 객체를 안전하지 않은 객체로부터 분리한다.  
런타임 지원은 전용 레지스터를 통해 인증된 명령을 통해서만 안전한 스택에 액세스할 수 있도록 함으로써 안전한 스택을 보호한다. 따라서 안전한 스택의 주소나 안전한 스택을 가리키는 포인터가 일반 스택에 저장되지 않으므로 안전한 객체가 안전하지 않은 객체를 손상시키는 것을 방지할 수 있다.  

Safe Stack 접근이 어떻게 작동하는지 정의하기 위해, 위에서 봤던 그림을 다시 보자.

![image](https://user-images.githubusercontent.com/73513005/159540476-6ee7b968-052c-4a69-ac12-ac670da8c830.png)

이 예제에서, Safe Stack 접근은 lct를 안전하다고 분류하고, 안전한 스택에 이를 배치할 것이다. 그리고 lbuf를 안전하지 않다고 분류, 기존(안전하지 않은) 스택에 놔둘 것이다. 변수 lct는 오직 스택 포인터로부터 일정한 오프셋을 사용해서만 접근할 수 있다. 반면에, lbuf는 line5에서 strlcpy에게 인자로 넘겨지고 있으며 strlcpy 내의 인자에 대한 접근은 스택 포인터로부터 일정한 오프셋을 가지지 않는다.  
추후, 프로그램 내의 버그가 메모리 참조를 lbuf에 대한 메모리 참조가 컴파일러가 정의한 것과는 다른 것으로 변경될 수 있으며 이러한 객체는 safe stack 접근법에 의해 안전하지 않다고 분류된다.  
strlcpy내의 lbuf를 스캔하는 포인터 동작은 일정한 오프셋을 가지지 않으므로 이 또한 안전하지 않다고 판단된다.

### Safe Stack 방어의 한계

Safe Stack 방어 기법이 멀티 스택 접근법을 적용, 안전한 스택을 고립시켜 런타임 체크를 없애지만 세이프 스택은 모든 세 가지 메모리 오류 종류의 안전성을 모두 검증하지 않으므로 일반적으로 데이터 객체를 보호하기에 불충분하다. 특히, Safe Stack은 타입 에러와 use-before-initialization를 전혀 고려하고 있지 않다.  
물론 Safe Stack의 주 목적은 코드 포인터를 지키는 것이지, 스택 객체를 지키는 것은 아니다. 코드 포인터를 위해, 타입 에러는 리턴 주소와 다른 안전한(Safe Stack) 코드 포인터 변수에 영향을 주지 않으며 use-before-initialization으로 코드 포인터 변수들을 공격하는 것은 극히 드물고 어렵다. 하지만, 타입적, 시간적 에러는 스택 데이터를 공격하는데 자주 사용되곤 한다.  

게다가, 세이프 스택 안전 요구사항은 지나치게 보수적이며 많은 객체들을 불필요하게 보호하지 않고 남긴다. 예를 들어, Safe Stack은 모든 주소를 받는 변수들, 즉 참조로 건네지는 모든 인자를 포함한 것들을 안전하지 않다고 정의하기에 특히 보수적이다. 이 논문에서는 이러한 객체들 중 많은 수가 세 종류의 메모리 에러에 대해 안전함을 증명할 수 있었다.  

요약하자면, 현존하는 멀티 스택 방어는 런타임 체크 없이 몇 스택 객체들을 보호하지만, 모든 세 가지 종류의 메모리 에러로부터 스택 객체를 체계적으로 지켜주진 못한다. 또한 이로 인해 만들어지는 false negative들은 스택 보호의 무결성을 위태롭게 한다.

## OVERVIEW

가장 중요한 도전은 공간적, 유형적, 시간적 메모리 에러로부터 안전한 스택 객체의 최대양을 구함과 동시에 안전하지 않은 스택 객체를 안전하다고 잘못 분류하지 않는 것이다. 이러한 안전한 스택 객체들은 고립되어 다른 객체의 안전하지 않은 접근으로부터 보호된다.

![image](https://user-images.githubusercontent.com/73513005/159638359-a72dc5e2-fbfa-4c2f-86ce-83593c7506e0.png)

다음 그림처럼, 여러 단계의 분석을 통해 잘못 분류됨 없이 안전을 체크한다.  
DATAGUARD의 목표를 정의하기 위해, 다음 그림의 예제를 보도록 하자.

![image](https://user-images.githubusercontent.com/73513005/159639107-2e8c982f-c9f3-4c7d-96e8-45c3ac2a581d.png)

함수 caller가 버퍼의 크기를 상수로 할당하여(i.e., imax, omax) 일정한 크기의 버퍼를 할당한다.(i.e., ibuf, obuf)  
Safe Stack 접근법의 주요 제한사항은 인자로 전달된 모든 스택 객체가 안전하지 않은 것으로 분류된다는 것이다.  
위 그림의 caller가 callee에게 상수와 버퍼를 건네는 동안 이들 인자 중 공간적, 유형적, 시간적 오류를 일으킬 수 있는 접근은 없다.  
먼저, caller가 signed integer 타입을 버퍼 사이즈에 사용하고 callee에서 변환되어 사용됨에도 불구하고(line 3, 8) 상수 값은 알려져 있으며 캐스트로 변경되지도 않는다. 그러므로 형식 에러는 불가능하다.  
두번째, 버퍼가 복사 명령에 사용되었음에도 불구하고(line3, 8), 복사본은 strlcpy 함수에 의해 제한 범위 내로 바인드된다. 절단으로 인한 보안 이슈는 이 논문에서 다뤄지지 않는다. 
시간적 안전에 대해서, 버퍼 참조가 초기화되면서, 그들의 값은 역참조 전에 초기화 된다. callee의 어떤 메모리도 이러한 참조에 할당되지 않는다.  
따라서, 버퍼와 버퍼 크기는 다른 불안전한 스택 객체(일반 스택) 및 기타 프로그램 객체에서의 메모리 오류로부터 보호하기 위해 다른 안전한 스택 객체를 위험하게 하지 않으면서 분리된 스택에 격리될 수 있다.  

DATAGUARD는 스택 객체의 안전을 세 단계로 증명한다.  

![image](https://user-images.githubusercontent.com/73513005/159638359-a72dc5e2-fbfa-4c2f-86ce-83593c7506e0.png)

위에서 봤던 그림과 동일하다. 차례로 보자면  

1. DATAGUARD는 각 스택 객체에 적용된 메모리 오류의 종류를 식별한다.

2. DATAGUARD는 메모리 안전 제약이라고 하는 메모리 오류의 각 종류에 대해 스택 객체의 안전성을 자동으로 검증하기 위한 제약을 생성한다.

3. DATAGUARD는 각 남아있는 스택 객체의 안전을 안전 제약을 통해 보장한다.

DATAGUARD는 정적 분석을 먼저 적용한다. 이를 통해 검증을 통과한 스택 객체들은 안전하다고 선언된다. 정적으로 안전을 찾지 못한 객체들을 위해, DATAGUARD는 두 번째 분석을 실행한다. 이번엔 targeted 기호 실행을 통해 안전을 검증한다. 안전하지 않은 객체를 잘못 분류해 안전하다고 판단하지 않기 위해서, 두 분석들이 프로그램의 가능한 실행을 지나치게 어림잡아야한다.(i.e., sound 분석) 어느 하나의 검증을 통과한 스택 객체는 안전하다고 선언된다. 다른 것들은 안전하지 않다고 선언된다.  
DATAGUARD는 Clang의 Safe Stack을 통해 안전하다고 판단된 스택 객체들을 보호한다.

## 디자인

앞에서 보여줬던 세 가지 절차를 자세히 보고, 안전 검증 분석을 위한 견고성을 담당하는 인자를 보여준다.  

1. 스택 객체를 위한 에러 종류 인식
   이 논문에서, 안전의 정의는 아무 객체를 alias하는 참조(포인터)가 객체와 관련된 공간적, 타입적, 시간적 안전 요건에 적합하며 참조 그 자체가 안전한 객체여야 한다.  
   DATAGUARD는 스택 객체를 alias하는 포인터들을 산출하고, 이들이 관련된 메모리 에러의 종류를 수집한다. 만약 어떤 스택 객체의 포인터도 메모리 에러를 일으킬 만한 명령을 수행하지 않았다면, 그 스택 객체는 안전하다.  
   DATAGUARD에서 스택 객체가 안전한지 파악하기 위해 가장 먼저 하는 단계는 안전 검증을 필요로 하는 각 스택 객체의 메모리 에러의 종류를 특정하는 것이다. 이를 위해, DATAGUARD는 CCured, SAFECode의 기술을 활용, 메모리 에러를 일으킬 수 있는 메모리 연산에 포인터를 사용할 수 있는지 여부를 판별한다. 스택 객체에서 검증되어져야 하는 메모리 에러의 종류들은 객체의 alias에 의해 발생되는 종류들의 집합이다.  
   CCured는 공간적, 타입적 에러를 일으킬 수 있는 포인터를 식별한다.  
   먼저, CCured는 포인터 산술 연산(array 요소 혹은 structure 필드에 접근)에 쓰이는 포인터가 공간적 에러를 일으킬 수 있다고 보여주고 있다. CCured는 이제 런타임 체크를 필요로 하는 반면, DATAGUARD는 공간적 에러 종류를 위한 검증이 필요한 그런 포인터를 참조하는 객체에 라벨을 붙인다.  
   둘째로, CCured는 타입 캐스팅 연산에 쓰이는 포인터들이 타입 에러를 일으킬 수 있다고 보여주고 있다. CCured는 안전을 검증하기 위해 다운캐스팅, 업캐스팅을 진행하지만 DATAGUARD는 마찬가지로 그러한 객체에 라벨을 붙인다. 주의할 점은, LLVM이 집합을 구조체나 primitive 타입으로 캐스트하고, 구성된 객체의 필드에 접근할 때 캐스트 명령을 자주 사용한다는 것이다. 이러한 케이스들은 DATAGUARD가 잡아낼 수 없다. 단, 스택 객체의 타입 에러가 흔하지 않고 대부분 즉석에서 이루어지기에, 여기서는 공간적 안전 규약을 통과하는 케이스의 수를 증가시키기 위해 타입 캐스트에 값이 영향 받지 않고 오직 integer의 unsigned-signed 캐스팅만을 판별한다.  
   DATAGUARD는 시간적 오류를 일으키는 명령을 판별하기 위해, 댕글링 포인터를 식별한다. SAFECode는 escape 분석을 기반으로 하는 댕글링 포인터에 걸리기 쉬운 스택 객체를 검증하는 메소드를 가지고 있다. escape 분석 전체를 실행하는 대신, DATAGUARD는 호출 함수 또는 다른 스레드(heap, globals)로 escape 할 수 있는 포인터를 alias에 따라 검출한다. 만약 어떤 포인터가 호출자로부터 통과된 포인터를 alias하거나, 포인터가 힙이나 전역 객체를 참조한다면, DATAGUARD는 시간적 분석의 필요성을 식별한다.  
   DATAGUARD는 초기화전 사용되거나, 오래된 메모리를 사용하여 시간적 오류를 불러일으킬 수 있는 스택 객체를 판별한다. 이 케이스에서는, 포인터와 테이터 변수가 초기화 전 사용이 쉽게 일어날 수 있다. 만약 변수가 선언시에 값이 초기화된다면, 시간적 분석이 필요하지 않고, 아니라면 필요하다.

2. 스택 객체 제약 수집
   DATAGUARD는 다음과 같은 접근으로 제약들을 수집한다.  
   먼저, 각 스택 객체에 대해 DATAGUARD는 안전 검증을 필요로 하는 메모리 오류 종류를 위해 스택 객체 선언으로부터 제약을 수집한다. 이 제약들은 스택 객체가 포인터에 할당될 때 마다 포인터에 할당된다. 정적 분석의 경우 포인터가 스택 객체에 alias를 지정할 수 있는지 여부에 따라 이러한 할당을 수행한다.  
   기호 실행에서, 이들은 기호 실행이 포인터에 의해 참조되어지는 스택 객체를 찾을 때 그러한 할당을 하게 만들었다.  
   1. 공간적 제약: 공간적 안전 점검은 객체의 크기를 경정하고 모든 접근이 그 크기에 의해 결정된 범위 안에 있는지 확인하는 것을 포함한다. 이러한 요건을 정적으로 확인하기 위해 다음과 같은 정보가 필요하다. 다음 4가지 제약 조건을 충족하지 않는 스택 객체는 보호되지 않은 일반 스택에 남게 된다.
      1. 선언: 객체의 기본 크기를 상수 값으로 선언해야 한다. 초기 인덱스는 0이다.
      2. 정의: 포인터가 객체를 참조하도록 정의될 때, 참조는 오프셋되어 인덱스를 변경할 수 있다. 이 오프셋은 상수 값이어야 한다.
      3. 사용: 포인터가 연산에서 사용될 때, 인덱스를 변경하기 위해 포인터를 더 오프셋할 수 있다. 각 사용되는 오프셋은 마찬가지로 상수여야 한다.
      4. 검증: 모든 사용에서, 포인터 인덱스는 크기보다 작아야하고, 인덱스는 0보다 커야 한다.
   2. 타입적 제약: 구조적 타입의 사용과 그들의 타입 캐스팅은 스택 객체에겐 덜 흔하다. 따라서 DATAGUARD는 정수 타입 캐스트의 안전 검증에 집중한다. 아래에서, 우리는 4가지 조건을 보여준다.
      1. 선언: 정수형 변수들은 선언에 사용되는 타입, 값(선택적)으로 할당된다.
      2. 정의: 포인터가 객체를 참조한다고 선언될 때, 만약 연산이 타입 캐스트를 포함한다면, newtype이 인식된다. 만약 인증이 성공한다면 타입은 newtype으로 할당된다.
      3. 사용: 포인터가 객체를 참조하기 위해 사용될 때, 만약 연산이 타입 캐스트를 포함한다면, newtype이 인식된다. 만약 인증이 성공한다면 타입은 newtype으로 할당된다. 만약 연산이 값으로 할당되면, 그 값을 저장한다.
      4. 검증: 새로운 유형을 생성하는 정의 또는 사용의 경우, 그 결과로 생긴 타입 캐스트는 참조되는 정수 객체의 값을 변경하지 않아야 한다.(e.g., 크기 변경 혹은 부호 변경)
   3. 시간적 제약: 여기서는 제약의 범위를 메모리의 초기화 전 사용, 해제 후 사용을 막기 위해 집중되었다.
      1. 정의: 객체가 basic block $b_{obj_{init}}$에서 선언되어지고, basic blocks의 집합 $B_{obj}$에서 살아있을 수 있다고 가정한다.
      2. 정의: 포인터가 basic block $b_{ptr_{obj}}$에서 정의된다.
      3. 사용: 포인터는 basic blocks $B_{ptr_{use}}$에서 사용된다.
      4. 검증: 포인터 정의는 객체가 살아있을 때 일어나며, $b_{ptr_{def}}∈B_{obj}$, 모든 basic block 내의 사용들은 객체가 아직 살아있는 basic block에서 발생한다. $B_{ptr_{use}}$ \\ $b_{ptr_{obj}}=0$.
   초기화 전 사용은 객체의 선언 전 alias가 사용되지 않는 한 일어나지 않고, 댕글링 포인터의 참조는 객체의 수명주기 이후의 사용이 일어나지 않는 한 일어나지 않는다.  
   이 제약조건은 객체의 선언에 따라 객체가 활성화 될 수 있는 basic block의 관점에서 정의한다. 그런 다음 DATAGUARD는 스택 객체가 활성 상태일 때 포인터 정의가 발생하고 모든 사용이 스택 객체가 활성 상태인 basic block에서 발생하는지 확인한다.

3. 스택 객체 안전 정적 증명
   저번 섹션에서 얻은 제약 조건을 바탕으로 스택 객체의 안전성을 검증하는 방법을 지정한다.  
   여기서 도전하는 것은 안전하지 않은 객체를 안전하다고 잘못 분류하는 일 없이 안전한 스택 객체의 수를 최대화함을 목표로 한다.  
   **공간적 안전 검증**
   먼저, 값 범위 분석[value range analysis](#value_range_analysis)에 쓰이는 두 단계 분석을 적용하여 이는 상수 입력을 사용하지 않거나 경계를 위반하는 것을 탐지한다. 전자가 더 가능성이 높기에, DATAGUARD는 이러한 데이터에 의존하는 포인터를 안전하지 않다고 분류하고, 나머지 케이스들을 분석한다.  
   path sensitivity가 부족하기에, false positive의 원인이 될 수 있는 부정확성이 발생한다는 것을 알 수 있으며 이는 복수의 프로그램 분기가 경계 위반을 잘못 가리키게 만드는데 영향을 끼칠 수 있다.  
   Symbolic 실행[symbolic execution](#targeted_symbolic_execution)은 이러한 패스를 제각각 확인할 수 있다. 모든 상수가 아닌 데이터는 symbolic으로 남아 있으며, 이러한 크기나 오프셋을 산출하는 symbolic 데이터의 사용은 안전 검증의 실패를 야기할 수 있다.  
   기호 실행을 사용하는데에 대한 도전은 [path explosion](#path_explosion)을 피하는 것이다. DATAGUARD는 정적 분석에서 발견된 양성(안전하지 않다고 가정되는) 케이스들에 적용되기에, 우리는 스택 객체의 선언에서 안전하지 않은 사용까지만 프로그램을 심볼릭하게 실행하면 되며, 이는 정적 없이 순수한 심볼릭 실행보다 안전한 사례를 식별할 수 있는 DATAGUARD의 능력을 향상시킨다.  
   또한 DATAGUARD는 S2E에서 채택한 기호 상태 병합을 활용하여 분기와 조우할 때 불필요한 포크를 제거함으로써 탐색 경로의 수를 크기 순서로 줄인다.  
   **타입 안전 검증**  
   타입 안전성 검증에는 유형 캐스트에서 값이 변경되지 않는지 점검하는 것이 포함되므로 타입 안전성 검증의 핵심은 정적 값 범위 분석에 있다. 타입 안전에 대해 검증된 스택 개체가 바인딩 또는 메모리(배열) 인덱스로도 사용되는 경우, DATAGUARD는 형식 안전성의 결과를 사용하여 공간 안전성을 검증한다.(즉, 인덱스에 사용되는 모든 정수는 형식 오류로부터 안전해야 한다.)
   **시간적 안전 검증**  
   댕글링 포인터를 검출하기 위한 제안된 접근법의 직관력은 참조된 스택 객체의 범위 밖에서 포인터 사용이 발생할 수 있는지 여부를 결정하는 것이다. 안전하지 않은 케이스를 안전하다고 잘못 분류하는 일 없이 이러한 케이스를 찾기 위해, DATAGUARD는 sound liveness analysis를 사용하여, 스택 객체가 프로그램에서 범위 내에 있는 basic block을 결정하고 스택 변수를 참조할 수 있는 포인터의 사용이 live set 밖의 basic block에서 발생하는지 여부를 판단한다. 단, aliasing에서는 false positive가 발생할 수 있기 때문에 실제로는 임의의 긍정적인 경우에 기호 실행을 사용하여 스택 객체에 포인터를 할당할 수 있는지 검증한다.  
   liveness analysis는 각 basic block에 활성 변수를 계산하기에 block $b_{obj_{init}}$에서 선언된 스택 개체가 $B_{obj}$으로 활성 상태인 basic block 집합을 결정할 수 있으며, 이를 obj의 활성 범위라고 부른다. 마찬가지로, obj를 alias할 수 있는 각 포인터들의 활성 범위를 산출하여 $B_{ptr}$을 결정한다. LLVM이 자신의 IR을 위해 SSA 형식을 쓰기 때문에, DATAGUARD는 각 포인터의 상대적인 스택 객체의 안전성을 개별적으로 평가한다. 자세하게는, 객체 *obj*를 alias할 수 있는 포인터 ptr의 활성 범위는 *ptr*이 선언될 때의 basic block이 시작되며, *ptr*의 마지막 사용 후에 끝난다. DATAGUARD는 각 포인터 *ptr*, alias된 객체 *obj*에 대해 *ptr*의 활성 범위 내에서의 사용이 *obj*의 라이브 범위 밖에 있는지 여부를 검증한다. 주목할만한 점은 alias는 스택 객체가 선언되기 전, 혹은 스택 객체의 활성 범위가 끝난 후에도 사용할 수 있다는 것이다. 정적 분석에서, 두 케이스 모두 안전하지 않은 스택 객체로 분류된다.  
   하지만, 활성 범위 검사를 통해 안전하지 않은 포인터가 발견되어도, 이것이 실제로 공격에 활용되지 않을 수도 있다. alias 검사의 과추정이 스택 객체를 실제로 참조할 수 없는 aliases를 식별할 수 있기 때문이다. 결과적으로, 안전하지 않은 것으로 판명된 각 스택 객체가 실제로 스택 객체의 라이브 범위 밖에서 사용될 수 있는 포인터에 할당되어 있는지 검증하기 위해 guided 기호 실행을 적용할 것을 제안한다. 기호 실행이 이러한 참조가 정적으로 시간적 검증에 실패한 모든 포인터에 대해 가능하지 않음을 증명하는 경우 스택 객체는 안전한 것으로 확인된다. 이를 위해, 산출된 def-use chain을 다시 추적한다. 각 스택 객체를 위해, 객체 선언 때 기호 실행을 시작하고 모든 alias에 대해 모든 def-use chains을 추적한다. 기호 공간적 검증과 비슷하게, path explosion을 피하기 위한 메소드을 포함한다.
4. 건전성 증명
   이 구간에서, 제안된 안전 검증을 위한 정적 분석과 기호적 실행의 건전성을 살펴볼 것이다.  
   **정적 분석 건전성**  
   안전 검증을 위한 정적 분석 방법은 여러 앞선 정적 분석들로 이루어져 있다. 각각 (1)LLVM's built-in def-use analysis, (2)SVF pointer analysis using its VFG, (3)Program Dependence Graph(PDG) of PtrSplit, (4)value range analysis, (5)live range analysis들로 이루어져 있다.  
   이 정적 분석들은 관련된 논문에서 그들의 건전성을 주장하고 있다. 하지만 이러한 논문들의 건전성 주장은 비공식적이다.(value range analysis 제외) 따라서, 이 분석들과 그 구현이 모든 케이스를 건전한 방법으로 다루지 못할 수도 있다. DATAGUARD가 의존하는 분석과 DATAGUARD가 그들을 어떻게 적용하는지 분리하기 위해, 다음으로 DATAGUARD의 정적 분석이 *상대적 건전성*을 달성한다고 주장한다. 즉, 그러한 이전 분석이 건전하다고 가정하면 DATAGURAD의 정적 분석은 건전하다.  
   DATAGUARD의 안전 검증 방법은 각 스택 객체를 alias 할 수 있는 모든 포인터를 찾는 과정이 필요하다. 이를 위해, DATAGUARD는 절차 간 may-aliases를 계산하고 함수 간의 데이터 흐름을 나타내기 위해 절차 내 VFG와 PtrSplit의 PDG 표현에 기초한 SVF 포인터 별칭 분석에 의존한다. VFG와 PDG 소개에서는 건전성을 주장하고 있으므로, DATAGUARD는 스택 객체를 alias할 수 있는 포인터의 집합을 건전하게 과추정할 수 있다.  
   공간적, 타입적 검증은 스택 객체를 접근할 수 있는 인덱스들의 가능한 범위를 산출하는 value range 분석을 적용한다. value range 분석은 PDG에 기반을 두고 계산하며 오직 단순한 패턴들을 추적한다. 그 패턴들은 다음과 같다. (1)스택 객체의 베이스로부터 상수 오프셋을 가진 포인터와 (2)포인터를 역참조할 때의 상수 오프셋이다. PDG가 건전성을 주장하고, 모든 상수가 read-only 메모리에 저장되며 read-write 메모리로 복사되지 않는다고 가정하기에, DATAGUARD의 value range 분석이 건전한 것은 명확하다.  
   시간적 검증은 liveness 분석을 적용하여 스택 객체가 활성 상태인 기본 블록을 객체에 별칭을 지정할 수 있는 각 포인터의 기본 블록과 비교한다. liveness 분석은 마찬가지로 PDG를 기반으로 계산하고, def-use chain과 객체의 범위을 추적한다. PDG가 건전하면, DATAGUARD의 liveness 분석도 건전함은 자명하다.  
   **기호 실행 건전성**  
   기본적으로, 기호 실행은 건전한 형태의 분석이다. 왜냐하면 프로그램의 모든 실행 경로를 따라가기 때문이다. 실제로는, 여러 요인들이 DATAGUARD가 다루틑 특정 기호 실행 분석의 건전성 보장을 어렵게 한다.
   1. 기호 실행에서의 path explosion은 프로그램 내의 모든 경로를 실행하는 것이 루프 정규화와 기호 상태 merging에도 불구하고 비현실적임을 뜻한다. DATAGUARD는 앞서 말했다시피 기호 실행의 깊이를 제한하여 비용이 비싼 케이스를 피하지만, 이러한 이유 때문에 종료되는 모든 기호 실행은 관련된 스택 객체를 안전하지 않다고 분류한다.  
   2. 기호 분석은 일부 변수에 대한 구체적인 값을 사용할 때 건전성을 희생할 수 있으며, 이는 동시 실행을 생성한다. DATAGUARD는 공간 안전 분석에서 상수인 값만 구체화한다. 다른 모든 변수는 기호 값으로 초기화 되며 오직 기호 값만이 시간 분석에서 변수를 초기화하기 위해 사용된다.
   3. 이 논문의 기호 분석은 프로그램 초기화에 시작되지 않는다. 따라서 다른 실행 문맥(스레드)가 생성된 경우 기호 실행 상태에 영향을 미칠 수 있다. DATAGUARD는 (한 번에) 단일 스택 개체가 공간 오류 및 시간 오류에 대해 안전한지 여부를 확인한다. 이는 성공했을 경우 오브젝트가 격리된 스택 상에 존재하며 이 스레드 등에서 안전하지 않은 글로벌, 스택 및 힙 오브젝트에 대한 액세스에 의한 조작으로부터 보호됨을 의미합니다.
   4. DATAGUARD의 기호 실행은 정적 분석에 의해 안전하지 않은 것으로 판명된 스택 객체를 검증할 때 def-use 체인을 건전하게 활용한다. 기호 실행 분석은 스택 객체의 선언에서 시작되며 스택 객체의 alias의 마지막 안전하지 않은 포인터 조작(사용)까지 프로그램을 기호적으로 실행한다. 따라서 메모리 오류를 일으킬 수 있는 모든 경로는 스택 개체가 안전하다고 선언되기 전에 기호적으로 실행된다.. DATAGUARD는 (정적 분석에 의해 증명된) 안전한 객체만 기호 실행에서 파생된 제약조건에 사용할 수 있도록 한다. 안전하지 않은 개체는 기호로 유지되므로 실행 중에 제한되지 않습니다. 루프를 단순화하기 위해 적용되는 루프 표준화[39]와 기호 상태 병합[70]도 건전하다.

## 평가

기존 논문들과 다르게, 이 논문은 Q&A 형식으로 평가를 진행하여 독자의 이해를 돕고 있다. 번역본은 다음과 같다.  
**스택 객체 안전 비교**  
**Q1.** DATAGUARD가 선행 기술보다 스택 객체를 얼마나 안전하게 보호하느냐?  
![image](https://user-images.githubusercontent.com/73513005/161805229-dfa68663-d71e-457f-babc-065ce03e3297.png)  
위 표1을 보면 알 수 있다시피 DATAGUARD는 평균 91.45%의 스택 객체의 안전함을 식별한다. 다른 검사(CCured, Safe Stack)에 비해 더 많은 객체를 안전하다고 판별해 격리하고, 이들에 대한 런타임 검사 없이 보호할 수 있게 된다.  
게다가, DATAGUARD는 안전하다고 간주되는 모든 스택 객체가 공간적, 유형적, 시간적 메모리 오류가 없도록 보장한다. CCured의 3%, Safe Stack의 6.3%의 안전한 것으로 분류된 객체가 DATAGUARD를 통해 안전하지 않음을 발견했다. 따라서 고립된 스택에서 이러한 객체들을 제거, 모든 스택 객체를 포괄적으로 보호한다.  

**오류 종류 판별**
**Q2.** 각 오류 종류에 대해 안전하지 않은 포인터 작업에 스택 개체가 사용되는 빈도는 얼마인가?  
![image](https://user-images.githubusercontent.com/73513005/161820778-e312720d-0097-414b-9ba0-28166d77a11c.png)  
위 그림을 보면, 우리는 스택 포인터의 14.24%가 공간 안전 유효성 검사를 필요로 하고, 3.92%가 유형 안전 유효성 검사를 요구하며, 17.39%가 시간 안전 유효성 검사를 요구한다는 것을 관찰한다. 따라서 추가 메모리 안전 유효성 검사가 필요한 스택 포인터는 27.3%인 것으로 나타났으며 72.70%는 모든 종류의 메모리 에러로부터 안전한 것으로 나타났다. 안전한 포인터로만 alias될 수 있는 스택 개체는 안전하며 추가 안전 검증이 필요하지 않습니다.  

**안전 제약 수집**  
**Q3.** 검증이 필요한 스택 개체 중 제약 조건과 연관될 수 없어 안전하지 않은 객체는 어떤 것인가?  
포인터 산술같은 명령에 사용되는 포인터에 의해 alias된 스택 객체는 공간 안전 제약 조건을 정적으로 수집하고 확인할 수 있다면 안전할 수 있다. 제안된 공간 안전 제약 조건에 기초하여, 안전 선언은 스택 객체 크기에 대한 일정한 크기를 지정해야 하며, 이는 C89 코딩 표준에서 필요하며 C99 코딩 표준에서 강력히 권장된다. DATAGUARD는 또한 이 스택 객체에 alias할 수 있는 모든 포인터를 사용할 때 일정 오프셋만큼 포인터를 증가시켜야 한다. 평균적으로 서버 프로그램과 SPEC CPU2006 벤치마크에서 공간 안전성 검증이 필요한 포인터의 25.65%가 이러한 요구 사항을 충족하지 못하므로, 이러한 포인터에 의해 별칭될 수 있는 관련 스택 개체는 안전하지 않다.  

**안전 제약 검증**  
**Q4.** 2단계 검증은 이전 작업에 비해 안전한 스택 객체를 식별하는 능력을 얼마나 향상시키는가?  
Nginx를 벤치마크로 사용하여 DATAGUARD의 공간 안전성 검증 및 시간적 안전성 검증의 각 단계가 스택 객체 안전성을 입증하는 능력에 어떤 영향을 미치는지 검토하기 위해 섹션 V-C에 설명된 DATAGUARD의 안전 제약 조건 검증을 평가한다. 서버 프로그램과 SPEC CPU 2006 벤치마크에 대한 자세한 평가 결과는 온라인 문서로도 제공됩니다.

1. 공간적 안전 검증: ![image](https://user-images.githubusercontent.com/73513005/161850781-46a3d114-c7df-466c-8638-968e18b3f2e9.png)  표 III는 nginx의 공간 안전성 검증 체계를 비교한다.  
CCured는 스택 오브젝트에 대한 모든 포인터 중 86.68%는 포인터 산술과 관련된 연산에 사용되지 않기 때문에 공간 오류로부터 안전하다고 분류한다. 이러한 모든 포인터가 실제로 공간 안전 제약 조건을 위반하지는 않는다는 관찰에 영감을 받아 DATAGUARD는 공간 안전 검증을 수행한다. DATAGUARD는 정적 분석과 심볼릭 실행의 조합을 적용하는데, 이는 CCured에 의한 안전하지 않은 포인터 1,374개(88.36%)가 DATAGUARD에서 공간 안전 검증을 통과한다는 것을 보여준다.  
기호실행과 정적분석이 미치는 영향을 별도로 살펴보면 377개(24.24%) 포인터가 기호실행만으로 공간안전해석을 통과하고 961개(61.80%) 포인터가 정적분석만으로 공간안전해석을 통과했다. 따라서 기호 실행이나 정적 분석만으로는 조합의 유효성에 접근하지 않는다. 또한 기호 실행은 정적 분석의 결과(예: def-use chain, 안전하지 않은 메모리의 위치)를 활용하므로 조합이 심볼릭 실행(377)보다 더 많은 안전한 포인터(413)를 찾을 수 있으며, 이는 정적 분석이 성공적인 검증에 필요한 깊이를 제한하는 제약 조건을 제공함을 보여주며, 더 많은 안전한 포인터의 유효성을 검사할 수 있게 해준다.
2. 시간적 안전 검증: ![image](https://user-images.githubusercontent.com/73513005/161853260-0c2a7688-4d6c-40cd-8ffa-40a85edf8291.png)  
표 IV는 nginx에 DATAGUARD의 시간적 안전성 검증 방법을 적용할 때 시간적 오류로부터 안전한 것으로 발견된 포인터의 수를 비교한다. 스택 객체를 참조할 수 있는 모든 포인터 중에서 Safe Stack의 방어는 88.00%가 시간적 안전 검증을 통과한다는 것을 발견했다. 그러나 Safe Stack은 스택 프레임을 교차하는 모든 참조를 안전하지 않은 것으로 분류하기 때문에 포인터가 다른 스택 프레임(address-taken 변수)으로 전달되지만 항상 alias 메모리 개체의 활성 범위 내에서 액세스되는 경우가 있을 수 있다.  
DATAGUARD의 시간적 안전성 검증은 표 IV에 표시된 세 부분으로 구성된다. DATAGUARD는 포인터가 시간적 오류가 발생할 수 있는지 여부를 결정하고 실시간 범위 분석(live range analysis)을 적용하고 마지막으로 유도 기호 실행(guided symbolic execution)을 적용한다. 첫째, 주소 지정 변수에 대한 포인터 중 966개(68.95%)는 시간적 오류를 일으킬 수 있는 연산이 부족하다. 이것은 대부분의 포인터가 초기화되어 있고 다른 스택 프레임의 스택 오브젝트처럼 별칭이 붙지 않는다는 것을 의미한다. 실시간 범위 분석을 적용한 후 DATAGUARD는 219개의 포인터가 시간적 오류로부터 안전하다는 것을 확인함으로써 주소 입력 변수에 대한 포인터의 84.58%를 포함하여 시간적 안전성 검증을 통과하는 포인터의 비율을 98.15%로 높였다. 마지막으로, 라이브 범위 분석으로 안전성이 입증될 수 없는 사례에 대한 기호 실행을 추가한 후, 시간 오류로부터 안전한 포인터 수가 전체의 99.20%로 증가하여 Safe Stack에 의해 안전하지 않다고 선언된 주소 사용 변수에 대한 포인터의 93.36%가 시간 안전 검증을 통과한다.  

**성능 평가**  
**Q5.** 안전한 스택 객체의 증가가 성능에 얼마나 영향을 주는가?  
이 섹션에서는 DATAGUARD의 분류가 nginx 및 SPEC CPU2006 벤치마크의 런타임 성능에 미치는 영향을 평가한다. DATAGUARD는 원래 Safe Stack 방어를 기반으로 Clang의 Safe Stack 보호 체계를 채택한다. 이러한 방어에서, 안전한 스택 객체만을 포함하는 함수는 분리된 스택만을 참조하는 반면, 안전하지 않은 스택 객체가 있는 함수는 이러한 객체에 대해 기존 스택 프레임을 할당한다. 함수에 안전한 스택 객체와 안전하지 않은 스택 객체가 모두 있는 경우 각 접근에 대한 올바른 스택 프레임을 선택하는 코드를 추가한다.  
따라서 안전한 스택 개체만 포함하는 스택 프레임의 비율이 클수록 성능이 향상된다. DATAGUARD, CCured 및 Clang의 Safe Stack for nginx와 SPEC CPU2006 벤치마크의 분류를 사용하여 안전한 스택 개체(안전 함수라고 함)만 포함하는 함수의 수를 측정한다. DATAGUARD는 평균적으로 함수의 76.12%가 안전함수인 반면 CCured와 Safe Stack은 각각 41.52%와 31.33%만 안전함수를 가지고 있음을 발견했다. 표 I에 표시된 세 가지 분류 체계에서 발견된 안전 스택 객체의 백분율 차이는 안전 함수의 약 절반 차이이며, 이는 객체가 안전하다는 것을 입증하는 노력의 중요성을 보여준다.  
![image](https://user-images.githubusercontent.com/73513005/161899526-d01479e5-bfb3-4024-99d3-4fb7a2410d92.png)  
그림 4는 DATAGUARD, CCured 및 Clang의 Safe Stack 시스템의 안전성 검증 결과를 사용한 Clang의 Safe Stack의 오버헤드를 보여준다. 기본 오버헤드(0%)는 보안 방지 메커니즘이 없는 소프트웨어를 의미하며 평균적으로 런타임 오버헤드는 CCured의 경우 8.6%, Clang의 Safe Stack의 경우 11.3%, DATAGUARD의 경우 4.3%이다. 따라서 안전한 개체만 있는 함수의 비율을 증가시키면 성능이 향상된다.  

**공격 완화**  
**Q6.** DATAGUARD가 프로그램의 보안을 향상시킬 수 있는가?  
DATAGUARD는 보호할 수 있는 안전한 개체의 수를 증가시키지만, 유효한 질문은 이것이 보안을 가시적으로 향상시키는지 여부이다. 문제는 일부 스택 개체가 일반 스택에 다른 안전하지 않은 개체와 함께 남아 있기 때문에 수행된 공격이 여전히 가능할 수 있다는 것이다.. 모든 공격에서 공격 개체(즉, 메모리 오류로 인해 공격된 개체)는 여전히 일반 스택(즉, 안전하지 않았기 때문에)에 있지만 대상 개체(즉, 공격을 사용하여 프로그램 실행을 가로채기 위해 악의적으로 읽거나 쓴 개체)는 분류에 따라 일반 스택에 있을 수도 있고 아닐 수도 있다. 대상 개체가 분리된 스택에 배치되지 않은 경우에, 공격이 가능하다.

## 결론

본 논문에서는 정적 분석과 심볼릭 실행을 활용하여 공간, 유형 및 시간 메모리 오류가 없는 스택 개체를 검증하는 DATAGUARD 시스템을 제시하였다. DATAGUARD는 3단계로 분석을 수행한다.  
첫째, DATAGUARD는 안전하지 않은 포인터 연산을 사용하는 포인터에 의해 이러한 개체가 참조될 수 있는지 여부를 결정함으로써 각 스택 개체에 대한 유효성 검사가 필요한 오류 클래스를 정적으로 식별한다.  
둘째, DATAGUARD는 공간, 유형 및 시간적 안전성을 검증하기 위해 메모리 안전 제약 조건을 자동으로 생성한다.  
셋째, DATAGUARD는 정적 분석과 심볼릭 실행 분석의 조합을 정확하게 적용하여 이전 기술보다 더 많은 수의 안전한 스택 개체를 식별할 수 있도록 하고, 안전하지 않은 스택 개체를 안전한 것으로 잘못 분류하는 것을 방지한다.  
DATAGUARD는 격리된 모든 안전 스택 개체가 세 가지 메모리 오류로부터 안전함을 보장하고 많은 추가 스택 개체를 증명하여 메모리 검사 없이 이러한 안전 스택 개체를 모두 보호할 수 있도록 보안을 강화한다. 또한 격리되어 보호할 수 있는 스택 객체의 범위를 늘리면 SPEC CPU2006 벤치마크에서 Clang의 Safe Stack 방어 기능을 사용하는 오버헤드가 11.3%에서 4.3%로 줄어든다. DATAGUARD는 https://github.com/Lightninghkm/DataGuard에서 이용할 수 있습니다.

<a name="targeted_symbolic_execution">targeted symbolic execution: 기호 실행은 컴퓨터 과학 및 컴퓨터 공학 분야에서 사용하는 용어로써, 컴퓨터 프로그램의 입력값에 대한 실행 경로를 분석하기 위한 기법</a>

<a name="value_range_analysis">value range analysis: data flow analysis의 한 종류이며, 프로그램 실행의 각 포인트에서 숫자 값이 가질 수 있는 값의 범위를 추적한다.</a>

<a name="path_explosion">path explosion: 프로그램 내의 실현가능한 path들의 수는 프로그램 크기의 증가와 비례하여 지수적으로 증가하고, 무한 루프 반복을 포함하는 경우 무한한 path를 가질 수 있다.</a>