---
layout: post
title: Preventing memory error exploits with WIT
categories: [thesis]
tags: [thesis, CFG, security]
fullview: true
comments: true
use_math: true
author: fault2000
---

## 개요

WIT는 간략하게 설명하자면, 분석을 통해 control-flow graph와 프로그램의 각 명령에 의해 쓰여지는 객체의 집합을 산출하고, 이러한 집합에 없는 객체를 명령어가 수정하는 것을 막는 코드 계측을 생성하며, control-flow graph에 의해 허용되어진 간접적인 제어 전달을 보장한다. 분석이 충분히 정밀하지 않은 커버리지를 향상하기 위해, WIT는 원본 프로그램 객체들 사이에 작은 경호원들을 삽입한다. 이 구현은 수정 없이 C와 C++ 프로그램들을 컴파일하기에, 실전에서 사용될 수 있다.

## 소개

위에서 어느 정도는 소개를 했고, 추가 설명을 덧붙이자면, 위에 추가 보호를 위해 객체들 사이 추가 경호원(guards)들을 넣어준다고 언급했는데, 이 가드들은 정적 분석에서 만들어진 집합에 속하지 않기에, 순차적인 오버플로우나 언더플로우가 발생하면 이들을 수정하게 되어 우리가 감지할 수 있다. WIT는 또한 CFI를 실시한다.  
WIT는 각 객체에 *색*을 부여하기 위해 points-to 분석을 사용하며, 각 쓰기 명령과 그 명령이 쓸 수 있는 모든 객체들은 같은 색을 가진다. WIT는 코드를 계측하면서 객체의 런타임에 색을 기록하고, 명령이 올바른 색에 쓰는지 검사한다. 메모리 위치의 색은 객체가 할당과 비할당될 때 업데이트되는 색 테이블에 기록된다. 쓰기 체크는 테이블에 적혀 있는 메모리 위치의 색을 찾고, 쓰기 명령의 색과 같은지를 검사한다. 이것은 write integrity를 보장한다.  
WIT는 간접적 호출 명령과 그 함수가 간접적으로 호출하는 함수에도 위와 같은 원리로 색을 부여하며, 이는 CFI(Control-flow Integrity)를 보장한다.  
공간 줄이기와 시간 오버헤드를 최적화하기 위해 여러 기법이 도입되었다. 첫째, 우리는 오직 안전하지 않은 쓰기만 계측하고 모든 안전한 객체에는 같은 색을 부여한다. 이것은 쓰기 체크의 갯수와 색 테이블 유지를 위한 오버헤드를 줄인다. 게다가, 이는 색을 표연하기 위해 필요한 비트의 수를 줄인다. 1 byte면 우리의 모든 연구에서 색을 나타내기에 충분했다. 둘째, 우리는 색 테이블에 함축된 표현을 사용하여 효율적으로 찾아볼 수 있도록 하였다. 색 테이블은 8 byte의 메모리 청크를 표기하기 위해 1 byte를 유지하며 이는 대략 12.5%의 공간 오버헤드를 줄인다. 셋째, 우리는 함수 호출 시 색 테이블 시작점을 업데이트하는 비용을 줄였다. 대부분의 지역 변수들은 안전하기에, 우리는 오직 함수의 시작 때 경비들과 안전하지 않은 변수들만 업데이트하고, 함수 종료 시 안전한 객체의 색으로 리셋시킨다.

## 개요

예시를 들어 설명하는데, 간단히 말하자면 처음 시작엔 points-to analysis를 통해 프로그램 속 각 명령어에 의해 수정될 수 있는 객체의 집합을 산출한다. 런타임 동안의 공간과 시간 오버헤드를 줄이기 위해, write safety 분석을 수행하여 안전한 명령과 객체들을 산출한다. 여기서 언급하는 안전이란, 명령어는 write integrity를 위반할 수 없는 경우, 객체는 이 객체를 수정할 수 있는 모든 명령이 안전하면 안전한 것으로 분류한다.  
points-to, write safety 분석들의 결과를 가지고 프로그램 속 객체와 명령에 각각 색을 부여한다. 색을 표현하기 위해 필요한 비트 수를 줄이기 위해 모든 안전한 객체와 명령에 색 0을 부여하였다.  
points-to 분석의 부정확성으로 인한 false negative를 줄이기 위해, 기존 프로그램의 안전하지 않은 객체 사이에 작은 가드들을 삽입하였다. 이 가드 객체들은 0 혹은 1의 색을 가지며 이 색들은 안전하지 않은 명령에 절대 할당되지 않고, 이는 WIT가 가드들 혹은 안전한 객체들을 덮어쓰는 시도를 감지할 수 있게 보장한다.  
points-to 분석은 또한 프로그램 속 간접적인 호출 명령에 의해 호출될 수 있는 함수를 산출하는데도 사용된다. 이러한 간접적인 호출 명령과 그들이 호출하는 함수에도 색을 할당하며, 이들이 구분되는 색을 가지도록 시도함과 동시에 각 명령과 그들이 호출하는 함수의 색이 같도록 한다. 함수에 할당되는 색의 집합은 안전하지 않은 객체와 안전한 객체, 가드들에게 할당되는 색의 집합과 구분된다. 이것은 안전하지 않은 명령이 코드 덮어쓰기와 코드 지역 바깥의 컨트롤 전달을 못하게 한다.  
WIT는 추가 컴파일 단계를 추가하여 write integrity와 control-flow integrity를 시행하는 instruction을 추가한다. 총 4가지 타입이 있으며, 각각 가드 추가, 색 테이블 유지, 쓰기 체크, 간접 호출 체크가 있다. 가드는 8 bytes 길이다.  
WIT는 색 테이블을 사용해 각 메모리 지역의 색을 기록한다. 객체가 할당되었을 때, 계측은 저장 공간의 색을 그곳을 차지하고 있는 객체의 색으로 맞춘다.  
우리는 색 테이블을 업데이트하는 비용을 최적화하였다. 먼저 모든 메모리 공간에 대한 색 테이블을 0으로 초기화하고, 안전한 객체가 스택에 할당될 때는 색 테이블을 업데이트하지 않는다. 대신, 함수 entry에서 안전하지 않은 객체에 상응하는 위치에 색을 업데이트한다.  
쓰기 검사는 쓰기를 실행하는 명령어의 색과 쓰여지고 있는 저장 위치의 색을 비교한다. 만약 색이 다르다면, 안전 예외를 제기한다. 각 명령에 색은 정적으로 알려져있고 쓰기 체크는 쓰여지고 있는 위치의 색을 색 테이블에서 찾아낸다. 성능을 위해 안전한 명령에는 쓰기 체크를 삽입하지 않는다.  
WIT는 또한 색 테이블에 간접적으로 호출될 수 있는 각 함수의 색을 기록한다. WIT는 프로그램 시작 시간에 색 테이블을 업데이트하고 감접적인 호출 시 색을 확인하기 위한 계측을 삽입한다. 간접적인 호출 체크는 간접적인 호출 명령의 색과 그 목표의 색을 비교한다. 만약 색이 다르다면, 예외를 제기한다.  
WIT는 write integrity를 위반하는 모든 공격들을 방지할 수 있다. 다만 이는 points-to 분석의 정확성에 달려있다. 예를 들어 만약 두 객체가 같은 색을 가지고 있다면, 포인터가 한 객체 대신 다른 객체에 쓰는 공격을 실행하는 것을 감지하는 것에 실패할 것이다. 이 연구는 분석이 위 경우를 어렵게 하기에 충분히 정확하다고 보여준다. 게다가, WIT는 points-to 분석의 정확도와 관계없이 많은 공격을 방지할 수 있다. 예를 들어, 다음과 같은 공격을 방지한다. 1. 객체의 경계가 겹칠 때까지 순차적으로 요소를 써내려가는 버퍼 오버, 언더플로우, 어떤 안전한 객체를 덮어쓰는 공격, 힙 관리 데이터 구조를 오염시키는 공격.  
CFI는 쓰기 체크가 공격에 실패했을 때 두 번째 방어를 제공한다. WIT는 모든 CFI를 위반하는 공격을 막으나, 위와 마찬가지로 points-to 분석에 정확도에 영향받는다. 예시로 많은 함수가 간접적 호출 명령과 같은 색을 가진다면, 공격자는 이 중 하나를 불러일으킬 수 있다. 그러나 최악의 경우에도, 함수 포인터를 오염시킨 공격자는 이 함수들만을 불러일으킬 수 있다. 게다가, 이러한 함수들은 동적 링킹 데이터 구조를 통해 간접적으로 불러일으킬 수 있는 라이브러리 함수를 포함하지 않는다. 따라서, 공격자는 오염된 함수 포인터를 통해 라이브러리 코드, 삽입된 코드, 실행가능한 메모리 지역 속 다른 주소로 이동할 수 없다.  
WIT는 out-of-bounds 읽기를 방지하지 못한다. 이는 confidential 데이터의 노출로 이어질 수 있으나, write integrity나 CFI를 위반하지 않고 이런 임의의 코드를 실행하여 confidential data를 공격하는 것은 대단히 어렵다. 따라서, 읽기 계측은 낮은 오버헤드를 위해 배재되었다.  

## 간단 요약

여기서는 구현을 위해 pheonix 컴파일러를 사용하고 있는데, 현재 피닉스 프로젝트는 종료된 것으로 보이므로, 구현에 대한 자세한 사항은 생략했다.  
WIT는 CFI를 구현함과 동시에 각종 객체가 쓸 수 있는 메모리 공간과 포인터에 '색'을 칠하고, 같은 색이 아닌 다른 색에 접근하면 오류를 제기한다. 이는 최근 리눅스 커널 v8.5-a 버전에서 적용된 memory tagging extension(이하, mte)과 비슷하다. 다만 차이점이 있다면 mte와는 달리 wit는 안전하다고 결정된 곳에는 색을 0 혹은 1을 할당하여 달리 색을 검사하진 않고, 대신 혹시 모를 overflow, underflow를 막기 위해 중간중간에 guard를 삽입하여 이들의 색이 안전하지 않은 공간의 색과 다른 것을 이용한다.  
그러나 mte가 더 나은 점이 더 많아보이는데, 먼저 mte는 색테이블에 정보를 저장하지 않고, 하드웨어적인 부분에서 색을 처리한다. 또한 가드들이 없어 공간 잡아먹기도 덜하고, 그로 인한 컴파일 과정이 더 단축된다. 아무래도 오래된 논문이다보니 기술적으로 뒤처지는 건 사실이지만, 이러한 아이디어가 있었다는 것에 만족하자.




