---
layout: post
title: CALI, Compiler-Assisted Library Isolation 리뷰
category: [thesis]
tags: [thesis, library]
fullview: true
comments: true
use_math: true
author: fault2000
---

CALI를 소개하는 논문이다.

## Introduction

프로그램은 그들 자신의 논리를 외부 라이브러리를 통해 확장하며, 이는 프로그래머의 삶을 쉽게 해준다. 그러나 서드 파티 라이브러리를 링킹하는 것은 중대한 보안 위험을 떠앉는다. 라이브러리는 메인 프로그램의 context 속에서 실행되기에, 프로그램 전체 주소 공간에 자유롭게 접근할 수 있고 프로그램의 시스템 수준의 권한을 물려받을 수 있다. 동시에 라이브러리는 위험한 기능을 자주 탑재한다.  
우리는 이러한 위협을 메인 프로그램으로부터 라이브러리를 격리하는 것으로 위협 수준을 상당히 줄일 수 있다. 대부분의 경우, 라이브러리는 전체 프로그램의 주소 공간에 접근할 필요가 없고, 모든 프로그램 권한 또한 필요 없다. 개념적으로, 믿을 수 없는 라이브러리가 프로그램 혹은 중요한 시스템 권한에 접근하도록 허가할 필요는 적다. 기본적인 구획화 원리는 다음과 같다.  
1. 메모리 고립은 믿을 수 없는 코드 부분(라이브러리)로부터 프로그램의 민감한 메모리를 보호한다.
2. 권한 분리는 믿을 수 없는 코드 부분의 권한의 집합을 줄인다.
자동화된 라이브러리 고립의 주요 도전은 프로그램과 라이브러리가 같은 주소 공간을 공유한다는 가정이다. 이 주소 공간을 분리하는 모든 시도는 적절히 처리되지 않는다면 내재된 의미를 해칠 수 있다. 문맥 간 데이터 전송은 primitive data type들과는 가볍게 할 수 있지만, 복잡한 객체들이라면 상당히 어려워진다. PtrSplit은 이 문제를 풀려고 시도한 첫 도전으로 복잡한 데이터 타입이 경계를 넘어갈 때마다 그들을 marshalling하는 방법을 사용했다. 방법론적으로, PtrSplit은 복잡한 객체의 경계를 추적하여 복잡한 객체를 복사하기 위해 필요한 필수적인 크기 정보를 수집한다. 자동화를 허용하는 이러한 분석은 

1. deep copy는 중대한 메모리, 성능 오버헤드를 만든다.
2. 복사에 대한 병렬 계산은 데이터 비연속성으로 이어진다.
3. PtrSplit의 분석은 type cast를 다루지 못한다.

특히 마지막 제한이 PtrSplit의 분석을 기반으로 type cast를 흔히 사용하는 라이브러리가 많기에 실전에서 가장 문제이다. 

## Overview

### Compiler-Assisted Library Isolation

이제 CALI에 대해 살펴보자. CALI를 쓰는 메인 타겟층은 C나 C++같은 언어로 쓰여진 애플리케이션에 흔한 라이브러리들을 링크하는 개발자 혹은 패키지 유지보수 담당이다.  우리는 이 라이브러리들 중 하나에 여러 취약점이 담겨져 있고, 이를 통해 공격자들이 전체 프로그램의 제어권을 획득할 수 있다고 가정한다. 개발자는 이러한 취약점으로 인해 발생하는 피해를 제한하고 싶다. 특히, 개인 정보와 시스템 무결성(백도어같은 시스템 수정)을 보호하고 싶어한다. 우리는 애플리케이션을 부수는 DoS 공격으로부터 보호하는 것을 원치 않는다. fault recovery는 우리의 범위 밖이다. 하지만, 우리는 자원 고갈 공격을 완화시키는 것에 집중할 것이다.  
애플리케이션은 휴대성을 잃지 말아야하며, 수정 전 실행되었던 것처럼 아무 시스템에서나 계속해서 작동되어야한다. 어떤 시스템 수정도 바라지않으며, 슈퍼-유저 권한은 설치 시간에나 런타임에나 가능하지 않다.  

#### Threat model

우리는 라이브러리가 공격자에게 라이브러리를 실행하는 프로세스 전체의 제어를 주거나 임의 코드 실행 같은 여러 취약점을 가지고 있다고 구상한다. 우리는 커널, 하드웨어 혹은 micro-architectural 공격은 신경 쓰지 않는다. 또한 견고한 권한 설정을 가정한다.

### Overview

CALI는 권한 분리를 적은 권한을 가진 코드 부분을 그들 자신의 문맥으로 고립시켜 수행한다. 이 개념은 일반적이기 때문에, 후에는 우리의 라이브러리 고립의 주 사용 케이스를 이것으로 고정할 것이다. CALI는 현재 inter-context 통신을 필요로 하는 애플리케이션과 라이브러리 간에 상호작용을 자동적으로 다룬다. 또한 CALI는 최소한으로 필요한 권한과 메모리만큼 라이브러리 문맥의 권한을 줄인다.  
우리의 보호는 애플리케이션 빌드 시간에 적용된다. 우리는 link-time optimization(LTO)와 함께 LLVM 툴체인을 이용하여 애플리케이션을 빌드한다. 애플리케이션을 링킹할 때, 모든 소스 코드 파일들은 LLVM bitcode로 사용가능하다. 처음으로, 우리는 정적, inter-procedural 분석을 전 애플리케이션에 수행한다. 이를 통해 라이브러리가 어디서 어떻게 사용되는지, 어떤 자원 즉 메인 애플리케이션에서 필요로 하는 메모리 지역 같은 자원들이 필요한지를 결정한다. 두 번째로, 메인 애플리케이션을 다시 쓴다. 우리는 모든 라이브러리 호출을 애플리케이션과 라이브러리 문맥 사이의 전환을 처리하는 스텁 함수에 대한 호출로 대체한다. 마지막으로, 최소화된 필수 프로그램 메모리 지역을 라이브러리 문맥이 접근 가능하도록 만든다.  
링킹 후, 결과물은 보통 리눅스 바이너리로 아무 리눅스 시스템에서 추가 의존 없이 실행된다. 개발자가 해주어야하는 상호작용은 최소한으로 진행된다.  

## SHIELDING COMPARTMENT

CALI는 모든 격리되어야하는 라이브러리를 위한 구획을 생성한다. 구획은 3가지 조건을 충족해야한다. 첫째, 권한 격리는 반드시 제공되어야 하며, 이를 위해 파일, 네트워크, 다른 자원들에 접근하는 것을 제한할 수 있어야한다. 둘째로, 구획은 라이브러리 구획에 있는 공격자로부터 특권을 가진 메인 애플리케이션을 보호하기 위해 메모리 고립을 제공해야 한다. 셋째로, 구획은 라이브러리로부터의 수정 필요없이 프로그램의 기능을 보존해야한다. 프로그램으로부터 라이브러리로 넘어가는 메모리 청크는 구획으로부터 접근가능해야하며, 그 역도 마찬가지이다.  

### Basic Compartment Structure

